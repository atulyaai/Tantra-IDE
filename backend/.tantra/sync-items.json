[
  {
    "id": "ad9f144ecbe50e1a55cab82ef8a3b325",
    "type": "workspace",
    "path": "/workspace/backend/.env.example",
    "content": "# Server Configuration\nPORT=3001\nNODE_ENV=development\n\n# Ollama Configuration\nOLLAMA_URL=http://localhost:11434\nOLLAMA_MODEL=qwen2.5-coder:7b\n\n# Workspace Configuration\nWORKSPACE_PATH=./workspace\n\n# Database Configuration (if using SQLite)\nDATABASE_PATH=./data/tantra.db\n\n# Security Configuration\nJWT_SECRET=your-super-secret-jwt-key-here\nBCRYPT_ROUNDS=12\n\n# Cloud Sync Configuration (optional)\nCLOUD_SYNC_ENABLED=false\nCLOUD_SYNC_PROVIDER=github\nCLOUD_SYNC_TOKEN=your-github-token-here\n\n# Performance Monitoring\nENABLE_PROFILING=false\nPROFILE_OUTPUT_DIR=./profiles",
    "hash": "5d93b4127392b3a56fba6d3714a85756",
    "lastModified": "2025-10-27T08:27:34.506Z",
    "synced": false
  },
  {
    "id": "e2027943ff9b742970ee519e0a265d8c",
    "type": "workspace",
    "path": "/workspace/backend/package.json",
    "content": "{\n  \"name\": \"tantra-ide-backend\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"tsx watch src/server.ts\",\n    \"build\": \"npx --package=typescript tsc\",\n    \"start\": \"node dist/server.js\",\n    \"type-check\": \"npx --package=typescript tsc --noEmit\",\n    \"lint\": \"echo \\\"No linter configured\\\" && exit 0\",\n    \"test\": \"echo \\\"No tests specified\\\" && exit 0\"\n  },\n  \"dependencies\": {\n    \"@types/bcrypt\": \"^6.0.0\",\n    \"@types/sqlite3\": \"^3.1.0\",\n    \"@types/cors\": \"^2.8.0\",\n    \"@types/express\": \"^4.17.0\",\n    \"@types/jsonwebtoken\": \"^9.0.10\",\n    \"@types/node\": \"^20.0.0\",\n    \"axios\": \"^1.6.0\",\n    \"bcrypt\": \"^6.0.0\",\n    \"sqlite3\": \"^5.1.0\",\n    \"chokidar\": \"^3.5.0\",\n    \"cors\": \"^2.8.5\",\n    \"dotenv\": \"^16.3.0\",\n    \"express\": \"^4.18.0\",\n    \"jsonwebtoken\": \"^9.0.2\",\n    \"puppeteer\": \"^22.0.0\",\n    \"sharp\": \"^0.33.0\",\n    \"simple-git\": \"^3.20.0\",\n    \"socket.io\": \"^4.7.0\",\n    \"v8-profiler-next\": \"^1.5.0\"\n  },\n  \"devDependencies\": {\n    \"tsx\": \"^4.7.0\",\n    \"typescript\": \"^5.3.0\"\n  }\n}\n",
    "hash": "56a757d5e897441d31f21d01f919e3ab",
    "lastModified": "2025-10-27T08:38:34.049Z",
    "synced": false
  },
  {
    "id": "b4d258bfb16bc10cda7b6262dc54799f",
    "type": "workspace",
    "path": "/workspace/backend/src/routes/agent.ts",
    "content": "import express from 'express';\nimport * as agentService from '../services/agentService.js';\n\nconst router = express.Router();\n\nrouter.post('/plan', async (req, res, next) => {\n  try {\n    const { goal, context } = req.body;\n    if (!goal) {\n      return res.status(400).json({ success: false, error: 'Goal is required' });\n    }\n    \n    const plan = await agentService.createTaskPlan(goal, context);\n    return res.json({ success: true, data: plan });\n  } catch (error) {\n    return next(error);\n  }\n});\n\nrouter.post('/execute-plan', async (req, res, next) => {\n  try {\n    const { plan } = req.body;\n    if (!plan) {\n      return res.status(400).json({ success: false, error: 'Plan is required' });\n    }\n    \n    const executedPlan = await agentService.executeTaskPlan(plan);\n    return res.json({ success: true, data: executedPlan });\n  } catch (error) {\n    return next(error);\n  }\n});\n\nrouter.post('/execute-task', async (req, res, next) => {\n  try {\n    const { task, context } = req.body;\n    if (!task) {\n      return res.status(400).json({ success: false, error: 'Task is required' });\n    }\n    \n    const executedTask = await agentService.executeTask(task, context);\n    return res.json({ success: true, data: executedTask });\n  } catch (error) {\n    return next(error);\n  }\n});\n\nrouter.get('/plans', async (_req, res, next) => {\n  try {\n    const plans = await agentService.getTaskPlans();\n    return res.json({ success: true, data: plans });\n  } catch (error) {\n    return next(error);\n  }\n});\n\nrouter.get('/plans/:id', async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    const plan = await agentService.getTaskPlan(id);\n    \n    if (!plan) {\n      return res.status(404).json({ success: false, error: 'Plan not found' });\n    }\n    \n    return res.json({ success: true, data: plan });\n  } catch (error) {\n    return next(error);\n  }\n});\n\nrouter.post('/plans', async (req, res, next) => {\n  try {\n    const { plan } = req.body;\n    if (!plan) {\n      return res.status(400).json({ success: false, error: 'Plan is required' });\n    }\n    \n    await agentService.saveTaskPlan(plan);\n    return res.json({ success: true, message: 'Plan saved successfully' });\n  } catch (error) {\n    return next(error);\n  }\n});\n\nrouter.get('/context', async (_req, res, next) => {\n  try {\n    const context = await agentService.getAgentContext();\n    return res.json({ success: true, data: context });\n  } catch (error) {\n    return next(error);\n  }\n});\n\nexport default router;\n",
    "hash": "3102091655115c5e8de3e3c3ac0d72c3",
    "lastModified": "2025-10-27T08:49:53.487Z",
    "synced": false
  },
  {
    "id": "243c2cb45e720737a9032d3eb737d945",
    "type": "workspace",
    "path": "/workspace/backend/src/routes/auth.ts",
    "content": "import express from 'express';\nimport { authService } from '../services/authService.js';\n\nconst router = express.Router();\n\n// Register new user\nrouter.post('/register', async (req, res, next) => {\n  try {\n    const { username, email, password } = req.body;\n    \n    if (!username || !email || !password) {\n      return res.status(400).json({ \n        success: false, \n        error: 'Username, email, and password are required' \n      });\n    }\n    \n    const user = await authService.register(username, email, password);\n    res.json({ success: true, data: { user: { ...user, passwordHash: undefined } } });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Login\nrouter.post('/login', async (req, res, next) => {\n  try {\n    const { username, password } = req.body;\n    \n    if (!username || !password) {\n      return res.status(400).json({ \n        success: false, \n        error: 'Username and password are required' \n      });\n    }\n    \n    const ipAddress = req.ip || req.connection.remoteAddress || 'unknown';\n    const userAgent = req.get('User-Agent') || 'unknown';\n    \n    const { user, session } = await authService.login(username, password, ipAddress, userAgent);\n    \n    res.json({ \n      success: true, \n      data: { \n        user: { ...user, passwordHash: undefined },\n        session: { ...session, token: undefined, refreshToken: undefined }\n      } \n    });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Logout\nrouter.post('/logout', async (req, res, next) => {\n  try {\n    const { sessionId } = req.body;\n    \n    if (!sessionId) {\n      return res.status(400).json({ \n        success: false, \n        error: 'Session ID is required' \n      });\n    }\n    \n    await authService.logout(sessionId);\n    res.json({ success: true, message: 'Logged out successfully' });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Logout all sessions\nrouter.post('/logout-all', async (req, res, next) => {\n  try {\n    const { userId } = req.body;\n    \n    if (!userId) {\n      return res.status(400).json({ \n        success: false, \n        error: 'User ID is required' \n      });\n    }\n    \n    await authService.logoutAll(userId);\n    res.json({ success: true, message: 'All sessions logged out' });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Validate token\nrouter.post('/validate', async (req, res, next) => {\n  try {\n    const { token } = req.body;\n    \n    if (!token) {\n      return res.status(400).json({ \n        success: false, \n        error: 'Token is required' \n      });\n    }\n    \n    const result = await authService.validateToken(token);\n    \n    if (result) {\n      res.json({ \n        success: true, \n        data: { \n          user: { ...result.user, passwordHash: undefined },\n          session: { ...result.session, token: undefined, refreshToken: undefined }\n        } \n      });\n    } else {\n      res.status(401).json({ success: false, error: 'Invalid token' });\n    }\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Refresh token\nrouter.post('/refresh', async (req, res, next) => {\n  try {\n    const { refreshToken } = req.body;\n    \n    if (!refreshToken) {\n      return res.status(400).json({ \n        success: false, \n        error: 'Refresh token is required' \n      });\n    }\n    \n    const result = await authService.refreshToken(refreshToken);\n    \n    if (result) {\n      res.json({ \n        success: true, \n        data: { \n          token: result.token,\n          session: { ...result.session, token: undefined, refreshToken: undefined }\n        } \n      });\n    } else {\n      res.status(401).json({ success: false, error: 'Invalid refresh token' });\n    }\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get user profile\nrouter.get('/profile/:userId', async (req, res, next) => {\n  try {\n    const { userId } = req.params;\n    const user = await authService.getUser(userId);\n    \n    if (!user) {\n      return res.status(404).json({ success: false, error: 'User not found' });\n    }\n    \n    res.json({ \n      success: true, \n      data: { user: { ...user, passwordHash: undefined } } \n    });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Update user preferences\nrouter.put('/preferences/:userId', async (req, res, next) => {\n  try {\n    const { userId } = req.params;\n    const preferences = req.body;\n    \n    await authService.updateUserPreferences(userId, preferences);\n    res.json({ success: true, message: 'Preferences updated' });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Change password\nrouter.put('/password/:userId', async (req, res, next) => {\n  try {\n    const { userId } = req.params;\n    const { currentPassword, newPassword } = req.body;\n    \n    if (!currentPassword || !newPassword) {\n      return res.status(400).json({ \n        success: false, \n        error: 'Current password and new password are required' \n      });\n    }\n    \n    await authService.changePassword(userId, currentPassword, newPassword);\n    res.json({ success: true, message: 'Password changed successfully' });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get all users (admin only)\nrouter.get('/users', async (req, res, next) => {\n  try {\n    const users = await authService.getAllUsers();\n    const sanitizedUsers = users.map(user => ({ ...user, passwordHash: undefined }));\n    res.json({ success: true, data: { users: sanitizedUsers } });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get active sessions\nrouter.get('/sessions', async (req, res, next) => {\n  try {\n    const sessions = await authService.getActiveSessions();\n    const sanitizedSessions = sessions.map(session => ({ \n      ...session, \n      token: undefined, \n      refreshToken: undefined \n    }));\n    res.json({ success: true, data: { sessions: sanitizedSessions } });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Check permission\nrouter.post('/permission', async (req, res, next) => {\n  try {\n    const { userId, permission } = req.body;\n    \n    if (!userId || !permission) {\n      return res.status(400).json({ \n        success: false, \n        error: 'User ID and permission are required' \n      });\n    }\n    \n    const hasPermission = await authService.hasPermission(userId, permission);\n    res.json({ success: true, data: { hasPermission } });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Cleanup expired sessions\nrouter.post('/cleanup', async (req, res, next) => {\n  try {\n    await authService.cleanupExpiredSessions();\n    res.json({ success: true, message: 'Expired sessions cleaned up' });\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;",
    "hash": "4bf36d3323b9dbc8d66ca4a26cc6d32e",
    "lastModified": "2025-10-27T08:49:22.995Z",
    "synced": false
  },
  {
    "id": "6eb8e8573ba97fa88547b0e7ece87fc4",
    "type": "workspace",
    "path": "/workspace/backend/src/routes/cloudSync.ts",
    "content": "import express from 'express';\nimport { cloudSyncService } from '../services/cloudSyncService.js';\n\nconst router = express.Router();\n\n// Enable cloud sync\nrouter.post('/enable', async (req, res, next) => {\n  try {\n    const { provider, repository, token } = req.body;\n    \n    if (!provider) {\n      return res.status(400).json({ \n        success: false, \n        error: 'Provider is required' \n      });\n    }\n    \n    await cloudSyncService.enableSync(provider, repository, token);\n    res.json({ success: true, message: 'Cloud sync enabled' });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Disable cloud sync\nrouter.post('/disable', async (req, res, next) => {\n  try {\n    await cloudSyncService.disableSync();\n    res.json({ success: true, message: 'Cloud sync disabled' });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Update sync configuration\nrouter.put('/config', async (req, res, next) => {\n  try {\n    const config = req.body;\n    await cloudSyncService.updateConfig(config);\n    res.json({ success: true, message: 'Configuration updated' });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get sync configuration\nrouter.get('/config', async (req, res, next) => {\n  try {\n    const config = await cloudSyncService.getConfig();\n    res.json({ success: true, data: config });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get sync status\nrouter.get('/status', async (req, res, next) => {\n  try {\n    const status = await cloudSyncService.getSyncStatus();\n    res.json({ success: true, data: status });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get sync items\nrouter.get('/items', async (req, res, next) => {\n  try {\n    const items = await cloudSyncService.getSyncItems();\n    res.json({ success: true, data: items });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Force sync\nrouter.post('/sync', async (req, res, next) => {\n  try {\n    await cloudSyncService.forceSync();\n    res.json({ success: true, message: 'Sync completed' });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Resolve conflict\nrouter.post('/conflicts/:id/resolve', async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    const { resolution } = req.body;\n    \n    if (!resolution || !['local', 'remote', 'merge'].includes(resolution)) {\n      return res.status(400).json({ \n        success: false, \n        error: 'Valid resolution is required (local, remote, or merge)' \n      });\n    }\n    \n    await cloudSyncService.resolveConflict(id, resolution);\n    res.json({ success: true, message: 'Conflict resolved' });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Scan workspace\nrouter.post('/scan', async (req, res, next) => {\n  try {\n    await cloudSyncService.scanWorkspace();\n    res.json({ success: true, message: 'Workspace scanned' });\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;",
    "hash": "8b3873220d5c38cb01cb8dda18def7e3",
    "lastModified": "2025-10-27T08:49:22.995Z",
    "synced": false
  },
  {
    "id": "106af4307a25da961ff8a980a2ad409e",
    "type": "workspace",
    "path": "/workspace/backend/src/routes/database.ts",
    "content": "import express from 'express';\nimport * as databaseService from '../services/databaseService.js';\n\nconst router = express.Router();\n\nrouter.get('/connections', async (req, res, next) => {\n  try {\n    const connections = await databaseService.detectDatabaseConnections();\n    res.json({ success: true, data: connections });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/test', async (req, res, next) => {\n  try {\n    const { connection } = req.body;\n    if (!connection) {\n      return res.status(400).json({ success: false, error: 'Connection is required' });\n    }\n    \n    const isConnected = await databaseService.testConnection(connection);\n    res.json({ success: true, data: { connected: isConnected } });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/query', async (req, res, next) => {\n  try {\n    const { connection, query } = req.body;\n    if (!connection || !query) {\n      return res.status(400).json({ success: false, error: 'Connection and query are required' });\n    }\n    \n    const result = await databaseService.executeQuery(connection, query);\n    res.json({ success: true, data: result });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/schema/:connectionId', async (req, res, next) => {\n  try {\n    const { connectionId } = req.params;\n    const { connection } = req.body;\n    \n    if (!connection) {\n      return res.status(400).json({ success: false, error: 'Connection is required' });\n    }\n    \n    const schema = await databaseService.getDatabaseSchema(connection);\n    res.json({ success: true, data: schema });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/query-builder/select', async (req, res, next) => {\n  try {\n    const { table, columns, where } = req.body;\n    if (!table) {\n      return res.status(400).json({ success: false, error: 'Table is required' });\n    }\n    \n    const query = databaseService.buildSelectQuery(table, columns, where);\n    res.json({ success: true, data: { query } });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/query-builder/insert', async (req, res, next) => {\n  try {\n    const { table, data } = req.body;\n    if (!table || !data) {\n      return res.status(400).json({ success: false, error: 'Table and data are required' });\n    }\n    \n    const query = databaseService.buildInsertQuery(table, data);\n    res.json({ success: true, data: { query } });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/query-builder/update', async (req, res, next) => {\n  try {\n    const { table, data, where } = req.body;\n    if (!table || !data || !where) {\n      return res.status(400).json({ success: false, error: 'Table, data, and where are required' });\n    }\n    \n    const query = databaseService.buildUpdateQuery(table, data, where);\n    res.json({ success: true, data: { query } });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/query-builder/delete', async (req, res, next) => {\n  try {\n    const { table, where } = req.body;\n    if (!table || !where) {\n      return res.status(400).json({ success: false, error: 'Table and where are required' });\n    }\n    \n    const query = databaseService.buildDeleteQuery(table, where);\n    res.json({ success: true, data: { query } });\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;\n",
    "hash": "7619f6249a8b55c22c1efde196fab8aa",
    "lastModified": "2025-10-27T08:49:22.995Z",
    "synced": false
  },
  {
    "id": "805d67e181cbd23e68472d711c7e0b60",
    "type": "workspace",
    "path": "/workspace/backend/src/routes/debug.ts",
    "content": "import express from 'express';\nimport { debugService } from '../services/debugService.js';\n\nconst router = express.Router();\n\n// Create debug session\nrouter.post('/sessions', async (req, res, next) => {\n  try {\n    const { name, type, config } = req.body;\n    \n    if (!name || !type || !config) {\n      return res.status(400).json({ \n        success: false, \n        error: 'Name, type, and config are required' \n      });\n    }\n    \n    const session = await debugService.createSession(name, type, config);\n    return res.json({ success: true, data: session });\n  } catch (error) {\n    return next(error);\n  }\n});\n\n// Start debug session\nrouter.post('/sessions/:id/start', async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    await debugService.startSession(id);\n    return res.json({ success: true, message: 'Debug session started' });\n  } catch (error) {\n    return next(error);\n  }\n});\n\n// Stop debug session\nrouter.post('/sessions/:id/stop', async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    await debugService.stopSession(id);\n    return res.json({ success: true, message: 'Debug session stopped' });\n  } catch (error) {\n    return next(error);\n  }\n});\n\n// Pause debug session\nrouter.post('/sessions/:id/pause', async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    await debugService.pauseSession(id);\n    return res.json({ success: true, message: 'Debug session paused' });\n  } catch (error) {\n    return next(error);\n  }\n});\n\n// Resume debug session\nrouter.post('/sessions/:id/resume', async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    await debugService.resumeSession(id);\n    return res.json({ success: true, message: 'Debug session resumed' });\n  } catch (error) {\n    return next(error);\n  }\n});\n\n// Get debug session\nrouter.get('/sessions/:id', async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    const session = debugService.getSession(id);\n    \n    if (!session) {\n      return res.status(404).json({ success: false, error: 'Debug session not found' });\n    }\n    \n    return res.json({ success: true, data: session });\n  } catch (error) {\n    return next(error);\n  }\n});\n\n// Get all debug sessions\nrouter.get('/sessions', async (_req, res, next) => {\n  try {\n    const sessions = debugService.getAllSessions();\n    return res.json({ success: true, data: sessions });\n  } catch (error) {\n    return next(error);\n  }\n});\n\n// Add breakpoint\nrouter.post('/sessions/:id/breakpoints', async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    const breakpoint = req.body;\n    \n    if (!breakpoint.file || !breakpoint.line) {\n      return res.status(400).json({ \n        success: false, \n        error: 'File and line are required' \n      });\n    }\n    \n    const newBreakpoint = await debugService.addBreakpoint(id, breakpoint);\n    return res.json({ success: true, data: newBreakpoint });\n  } catch (error) {\n    return next(error);\n  }\n});\n\n// Remove breakpoint\nrouter.delete('/sessions/:id/breakpoints/:breakpointId', async (req, res, next) => {\n  try {\n    const { id, breakpointId } = req.params;\n    await debugService.removeBreakpoint(id, breakpointId);\n    return res.json({ success: true, message: 'Breakpoint removed' });\n  } catch (error) {\n    return next(error);\n  }\n});\n\n// Update breakpoint\nrouter.put('/sessions/:id/breakpoints/:breakpointId', async (req, res, next) => {\n  try {\n    const { id, breakpointId } = req.params;\n    const updates = req.body;\n    \n    await debugService.updateBreakpoint(id, breakpointId, updates);\n    return res.json({ success: true, message: 'Breakpoint updated' });\n  } catch (error) {\n    return next(error);\n  }\n});\n\n// Step over\nrouter.post('/sessions/:id/step-over', async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    await debugService.stepOver(id);\n    return res.json({ success: true, message: 'Step over executed' });\n  } catch (error) {\n    return next(error);\n  }\n});\n\n// Step into\nrouter.post('/sessions/:id/step-into', async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    await debugService.stepInto(id);\n    return res.json({ success: true, message: 'Step into executed' });\n  } catch (error) {\n    return next(error);\n  }\n});\n\n// Step out\nrouter.post('/sessions/:id/step-out', async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    await debugService.stepOut(id);\n    return res.json({ success: true, message: 'Step out executed' });\n  } catch (error) {\n    return next(error);\n  }\n});\n\n// Continue\nrouter.post('/sessions/:id/continue', async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    await debugService.continue(id);\n    return res.json({ success: true, message: 'Continue executed' });\n  } catch (error) {\n    return next(error);\n  }\n});\n\n// Evaluate expression\nrouter.post('/sessions/:id/evaluate', async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    const { expression } = req.body;\n    \n    if (!expression) {\n      return res.status(400).json({ \n        success: false, \n        error: 'Expression is required' \n      });\n    }\n    \n    const result = await debugService.evaluateExpression(id, expression);\n    return res.json({ success: true, data: result });\n  } catch (error) {\n    return next(error);\n  }\n});\n\n// Get variables\nrouter.get('/sessions/:id/variables', async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    const { frameId } = req.query;\n    \n    const variables = await debugService.getVariables(id, frameId ? parseInt(frameId as string) : undefined);\n    return res.json({ success: true, data: Array.from(variables.entries()) });\n  } catch (error) {\n    return next(error);\n  }\n});\n\n// Get call stack\nrouter.get('/sessions/:id/call-stack', async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    const callStack = await debugService.getCallStack(id);\n    return res.json({ success: true, data: callStack });\n  } catch (error) {\n    return next(error);\n  }\n});\n\n// Set current frame\nrouter.post('/sessions/:id/frame', async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    const { frameId } = req.body;\n    \n    if (frameId === undefined) {\n      return res.status(400).json({ \n        success: false, \n        error: 'Frame ID is required' \n      });\n    }\n    \n    await debugService.setCurrentFrame(id, frameId);\n    return res.json({ success: true, message: 'Current frame set' });\n  } catch (error) {\n    return next(error);\n  }\n});\n\nexport default router;",
    "hash": "8b01ae0ace1cd5e76243050abce9f9a6",
    "lastModified": "2025-10-27T08:49:22.995Z",
    "synced": false
  },
  {
    "id": "89c28c8b42111ec94295f03ca5c7f92d",
    "type": "workspace",
    "path": "/workspace/backend/src/routes/deployment.ts",
    "content": "import express from 'express';\nimport * as deploymentService from '../services/deploymentService.js';\n\nconst router = express.Router();\n\nrouter.post('/deploy', async (req, res, next) => {\n  try {\n    const { platform, projectName, buildCommand, outputDirectory, environmentVariables, customDomain } = req.body;\n    \n    if (!platform || !projectName) {\n      return res.status(400).json({ success: false, error: 'Platform and project name are required' });\n    }\n\n    const config = {\n      platform,\n      projectName,\n      buildCommand,\n      outputDirectory,\n      environmentVariables,\n      customDomain,\n    };\n\n    const result = await deploymentService.deployProject(config);\n    res.json({ success: true, data: result });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/platforms', async (req, res, next) => {\n  try {\n    const platforms = await deploymentService.checkPlatformAvailability();\n    res.json({ success: true, data: platforms });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/config', async (req, res, next) => {\n  try {\n    const config = await deploymentService.detectDeploymentConfig();\n    res.json({ success: true, data: config });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/history', async (req, res, next) => {\n  try {\n    const history = await deploymentService.getDeploymentHistory();\n    res.json({ success: true, data: history });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/install-cli', async (req, res, next) => {\n  try {\n    const { platform } = req.body;\n    \n    if (!platform) {\n      return res.status(400).json({ success: false, error: 'Platform is required' });\n    }\n\n    let command: string;\n    switch (platform) {\n      case 'vercel':\n        command = 'npm install -g vercel';\n        break;\n      case 'netlify':\n        command = 'npm install -g netlify-cli';\n        break;\n      case 'aws':\n        return res.status(400).json({ \n          success: false, \n          error: 'AWS CLI must be installed manually. Visit: https://aws.amazon.com/cli/' \n        });\n      default:\n        return res.status(400).json({ success: false, error: 'Unsupported platform' });\n    }\n\n    const { exec } = await import('child_process');\n    const { promisify } = await import('util');\n    const execAsync = promisify(exec);\n\n    await execAsync(command);\n    res.json({ success: true, message: `${platform} CLI installed successfully` });\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;",
    "hash": "0c1664d0688c98396edaa65dd27f87c8",
    "lastModified": "2025-10-27T08:49:22.995Z",
    "synced": false
  },
  {
    "id": "7590b14aa6342094189f4b6965f1b782",
    "type": "workspace",
    "path": "/workspace/backend/src/routes/files.ts",
    "content": "import express from 'express';\nimport * as fileService from '../services/fileService.js';\n\nconst router = express.Router();\n\n// Get file tree\nrouter.get('/tree', async (req, res, next) => {\n  try {\n    const path = (req.query.path as string) || '.';\n    const tree = await fileService.getFileTree(path);\n    res.json({ success: true, data: tree });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Read file\nrouter.get('/read', async (req, res, next) => {\n  try {\n    const path = req.query.path as string;\n    if (!path) {\n      return res.status(400).json({ success: false, error: 'Path is required' });\n    }\n    const content = await fileService.readFile(path);\n    const stats = await fileService.getFileStats(path);\n    res.json({ \n      success: true, \n      data: { \n        path, \n        content,\n        size: stats.size,\n        modified: stats.modified,\n        created: stats.created\n      } \n    });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Write file\nrouter.post('/write', async (req, res, next) => {\n  try {\n    const { path, content } = req.body;\n    if (!path || content === undefined) {\n      return res.status(400).json({ success: false, error: 'Path and content are required' });\n    }\n    await fileService.writeFile(path, content);\n    res.json({ success: true, message: 'File saved successfully' });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Create file\nrouter.post('/create', async (req, res, next) => {\n  try {\n    const { path, content = '' } = req.body;\n    if (!path) {\n      return res.status(400).json({ success: false, error: 'Path is required' });\n    }\n    await fileService.createFile(path, content);\n    res.json({ success: true, message: 'File created successfully' });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Delete file\nrouter.delete('/delete', async (req, res, next) => {\n  try {\n    const path = req.query.path as string;\n    if (!path) {\n      return res.status(400).json({ success: false, error: 'Path is required' });\n    }\n    await fileService.deleteFile(path);\n    res.json({ success: true, message: 'File deleted successfully' });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Rename file\nrouter.post('/rename', async (req, res, next) => {\n  try {\n    const { oldPath, newPath } = req.body;\n    if (!oldPath || !newPath) {\n      return res.status(400).json({ success: false, error: 'Old and new paths are required' });\n    }\n    await fileService.renameFile(oldPath, newPath);\n    res.json({ success: true, message: 'File renamed successfully' });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Create folder\nrouter.post('/create-folder', async (req, res, next) => {\n  try {\n    const { path } = req.body;\n    if (!path) {\n      return res.status(400).json({ success: false, error: 'Path is required' });\n    }\n    await fileService.createFolder(path);\n    res.json({ success: true, message: 'Folder created successfully' });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Search files\nrouter.get('/search', async (req, res, next) => {\n  try {\n    const pattern = req.query.pattern as string;\n    const path = (req.query.path as string) || '.';\n    \n    if (!pattern) {\n      return res.status(400).json({ success: false, error: 'Pattern is required' });\n    }\n    \n    const results = await fileService.searchFiles(pattern, path);\n    res.json({ success: true, data: results });\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;\n\n",
    "hash": "bb999217dd48b21069b6b72d6a0175a2",
    "lastModified": "2025-10-27T08:49:22.995Z",
    "synced": false
  },
  {
    "id": "d506f9707cbd3b42e03a4166d3ff439e",
    "type": "workspace",
    "path": "/workspace/backend/src/routes/git.ts",
    "content": "import express from 'express';\nimport * as gitService from '../services/gitService.js';\n\nconst router = express.Router();\n\nrouter.get('/status', async (req, res, next) => {\n  try {\n    const isRepo = await gitService.isGitRepository();\n    if (!isRepo) {\n      return res.json({ success: true, data: [] });\n    }\n    \n    const changes = await gitService.getGitStatus();\n    res.json({ success: true, data: changes });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/diff', async (req, res, next) => {\n  try {\n    const isRepo = await gitService.isGitRepository();\n    if (!isRepo) {\n      return res.json({ success: true, data: '' });\n    }\n    \n    const path = req.query.path as string;\n    const diff = await gitService.getGitDiff(path);\n    res.json({ success: true, data: diff });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/commit', async (req, res, next) => {\n  try {\n    const { message, files } = req.body;\n    if (!message) {\n      return res.status(400).json({ success: false, error: 'Commit message is required' });\n    }\n    \n    await gitService.commitChanges(message, files);\n    res.json({ success: true, message: 'Changes committed successfully' });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/push', async (req, res, next) => {\n  try {\n    const { remote = 'origin', branch = 'main' } = req.body;\n    await gitService.pushChanges(remote, branch);\n    res.json({ success: true, message: 'Changes pushed successfully' });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/pull', async (req, res, next) => {\n  try {\n    const { remote = 'origin', branch = 'main' } = req.body;\n    await gitService.pullChanges(remote, branch);\n    res.json({ success: true, message: 'Changes pulled successfully' });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/branch', async (req, res, next) => {\n  try {\n    const branch = await gitService.getCurrentBranch();\n    res.json({ success: true, data: branch });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/branches', async (req, res, next) => {\n  try {\n    const branches = await gitService.getBranches();\n    res.json({ success: true, data: branches });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/branch', async (req, res, next) => {\n  try {\n    const { name, action = 'create' } = req.body;\n    if (!name) {\n      return res.status(400).json({ success: false, error: 'Branch name is required' });\n    }\n    \n    if (action === 'create') {\n      await gitService.createBranch(name);\n    } else if (action === 'switch') {\n      await gitService.switchBranch(name);\n    }\n    \n    res.json({ success: true, message: `Branch ${action} successful` });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/history', async (req, res, next) => {\n  try {\n    const limit = parseInt(req.query.limit as string) || 10;\n    const history = await gitService.getGitHistory(limit);\n    res.json({ success: true, data: history });\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;\n\n",
    "hash": "d0a6997221ddc81b13fc1046a0614df1",
    "lastModified": "2025-10-27T08:49:22.995Z",
    "synced": false
  },
  {
    "id": "712c4ff3ee963c2b20f83058f45f5d92",
    "type": "workspace",
    "path": "/workspace/backend/src/routes/media.ts",
    "content": "import express from 'express';\nimport * as mediaService from '../services/mediaService.js';\n\nconst router = express.Router();\n\nrouter.get('/all', async (req, res, next) => {\n  try {\n    const mediaFiles = await mediaService.getAllMediaFiles();\n    res.json({ success: true, data: mediaFiles });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/tag', async (req, res, next) => {\n  try {\n    const { path } = req.body;\n    if (!path) {\n      return res.status(400).json({ success: false, error: 'Path is required' });\n    }\n    \n    const tags = await mediaService.tagImageWithAI(path);\n    res.json({ success: true, data: tags });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/optimize', async (req, res, next) => {\n  try {\n    const { path, options = {} } = req.body;\n    if (!path) {\n      return res.status(400).json({ success: false, error: 'Path is required' });\n    }\n    \n    await mediaService.optimizeImage(path, options);\n    res.json({ success: true, message: 'Image optimized successfully' });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/find-usage', async (req, res, next) => {\n  try {\n    const { path } = req.body;\n    if (!path) {\n      return res.status(400).json({ success: false, error: 'Path is required' });\n    }\n    \n    const usage = await mediaService.findAssetUsage(path);\n    res.json({ success: true, data: usage });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/stats', async (req, res, next) => {\n  try {\n    const stats = await mediaService.getMediaStats();\n    res.json({ success: true, data: stats });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/unused', async (req, res, next) => {\n  try {\n    const unusedAssets = await mediaService.detectUnusedAssets();\n    res.json({ success: true, data: unusedAssets });\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;\n\n",
    "hash": "6811cb27b7992d24cf683ee36015db32",
    "lastModified": "2025-10-27T08:49:22.995Z",
    "synced": false
  },
  {
    "id": "d64ffce0c4aed31bd9bc6a693b7c909a",
    "type": "workspace",
    "path": "/workspace/backend/src/routes/ollama.ts",
    "content": "import express from 'express';\nimport { checkOllamaConnection, listModels } from '../services/ollamaService.js';\n\nconst router = express.Router();\n\nrouter.get('/status', async (req, res, next) => {\n  try {\n    const connected = await checkOllamaConnection();\n    res.json({ success: true, data: { connected } });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/models', async (req, res, next) => {\n  try {\n    const models = await listModels();\n    res.json({ success: true, data: models });\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;\n\n",
    "hash": "2681f9801cf8f891b3435a4fd7c9ea0e",
    "lastModified": "2025-10-27T08:49:22.995Z",
    "synced": false
  },
  {
    "id": "3007704375e1449f46a5a0839b9b8c73",
    "type": "workspace",
    "path": "/workspace/backend/src/routes/packages.ts",
    "content": "import express from 'express';\nimport * as packageService from '../services/packageService.js';\n\nconst router = express.Router();\n\nrouter.get('/detect-missing', async (req, res, next) => {\n  try {\n    const missing = await packageService.detectMissingDependencies();\n    res.json({ success: true, data: missing });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/install', async (req, res, next) => {\n  try {\n    const { packageName, manager = 'npm' } = req.body;\n    if (!packageName) {\n      return res.status(400).json({ success: false, error: 'Package name is required' });\n    }\n    \n    await packageService.installPackage(packageName, manager);\n    res.json({ success: true, message: 'Package installed successfully' });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/tree', async (req, res, next) => {\n  try {\n    const manager = (req.query.manager as string) || 'npm';\n    const tree = await packageService.getDependencyTree(manager);\n    res.json({ success: true, data: tree });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/update', async (req, res, next) => {\n  try {\n    const { manager = 'npm' } = req.body;\n    await packageService.updatePackages(manager);\n    res.json({ success: true, message: 'Packages updated successfully' });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/manager', async (req, res, next) => {\n  try {\n    const manager = await packageService.detectPackageManager();\n    res.json({ success: true, data: manager });\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;\n\n",
    "hash": "93ad577036ee581b7b4d13bdb7ee808b",
    "lastModified": "2025-10-27T08:49:22.995Z",
    "synced": false
  },
  {
    "id": "9ceeb421529d731d129bc4e8d82c516c",
    "type": "workspace",
    "path": "/workspace/backend/src/routes/performance.ts",
    "content": "import express from 'express';\nimport * as performanceService from '../services/performanceService.js';\n\nconst router = express.Router();\n\nrouter.get('/bundle', async (req, res, next) => {\n  try {\n    const analysis = await performanceService.analyzeBundle();\n    res.json({ success: true, data: analysis });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/lighthouse', async (req, res, next) => {\n  try {\n    const { url } = req.query;\n    const report = await performanceService.runPerformanceProfile(url as string);\n    res.json({ success: true, data: report });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/memory', async (req, res, next) => {\n  try {\n    const profile = await performanceService.runMemoryProfile();\n    res.json({ success: true, data: profile });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/cpu', async (req, res, next) => {\n  try {\n    const { duration = '10000' } = req.query;\n    const profile = await performanceService.runCPUProfile(parseInt(duration as string));\n    res.json({ success: true, data: profile });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/network', async (req, res, next) => {\n  try {\n    const { url } = req.query;\n    const analysis = await performanceService.analyzeNetworkRequests(url as string);\n    res.json({ success: true, data: analysis });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/report', async (req, res, next) => {\n  try {\n    const report = await performanceService.generatePerformanceReport();\n    res.json({ success: true, data: report });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/suggestions', async (req, res, next) => {\n  try {\n    const { bundle, lighthouse } = req.body;\n    const suggestions = await performanceService.getOptimizationSuggestions(bundle, lighthouse);\n    res.json({ success: true, data: suggestions });\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;\n",
    "hash": "3fc9b862e7a0f1ea389b6c32809b0e77",
    "lastModified": "2025-10-27T08:49:22.995Z",
    "synced": false
  },
  {
    "id": "6dd41b8b8804d10b95974c42d18928e3",
    "type": "workspace",
    "path": "/workspace/backend/src/routes/plugins.ts",
    "content": "import express from 'express';\nimport { pluginManager } from '../services/pluginService.js';\n\nconst router = express.Router();\n\n// Get all plugins\nrouter.get('/', async (req, res, next) => {\n  try {\n    const plugins = pluginManager.getPlugins();\n    res.json({ success: true, data: plugins });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get specific plugin\nrouter.get('/:id', async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    const plugin = pluginManager.getPlugin(id);\n    \n    if (!plugin) {\n      return res.status(404).json({ success: false, error: 'Plugin not found' });\n    }\n    \n    res.json({ success: true, data: plugin });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Install plugin\nrouter.post('/install', async (req, res, next) => {\n  try {\n    const { packageName, version } = req.body;\n    \n    if (!packageName) {\n      return res.status(400).json({ success: false, error: 'Package name is required' });\n    }\n    \n    const plugin = await pluginManager.installPlugin(packageName, version);\n    res.json({ success: true, data: plugin });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Uninstall plugin\nrouter.delete('/:id', async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    await pluginManager.uninstallPlugin(id);\n    res.json({ success: true, message: 'Plugin uninstalled successfully' });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Enable plugin\nrouter.post('/:id/enable', async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    await pluginManager.enablePlugin(id);\n    res.json({ success: true, message: 'Plugin enabled successfully' });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Disable plugin\nrouter.post('/:id/disable', async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    await pluginManager.disablePlugin(id);\n    res.json({ success: true, message: 'Plugin disabled successfully' });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Execute plugin command\nrouter.post('/command', async (req, res, next) => {\n  try {\n    const { command, context } = req.body;\n    \n    if (!command) {\n      return res.status(400).json({ success: false, error: 'Command is required' });\n    }\n    \n    const result = await pluginManager.executeCommand(command, context || {});\n    res.json({ success: true, data: result });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get plugin commands\nrouter.get('/commands/list', async (req, res, next) => {\n  try {\n    const commands = pluginManager.getCommands();\n    res.json({ success: true, data: commands });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get plugin keybindings\nrouter.get('/keybindings/list', async (req, res, next) => {\n  try {\n    const keybindings = pluginManager.getKeybindings();\n    res.json({ success: true, data: keybindings });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get plugin views\nrouter.get('/views/list', async (req, res, next) => {\n  try {\n    const views = pluginManager.getViews();\n    res.json({ success: true, data: views });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get plugin languages\nrouter.get('/languages/list', async (req, res, next) => {\n  try {\n    const languages = pluginManager.getLanguages();\n    res.json({ success: true, data: languages });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Load all plugins\nrouter.post('/load-all', async (req, res, next) => {\n  try {\n    const plugins = await pluginManager.loadAllPlugins();\n    res.json({ success: true, data: plugins });\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;",
    "hash": "e07fa71519d51374daa0906ca3a1c976",
    "lastModified": "2025-10-27T08:49:22.995Z",
    "synced": false
  },
  {
    "id": "173603edf6abfd5be32bccb47b783e7f",
    "type": "workspace",
    "path": "/workspace/backend/src/routes/search.ts",
    "content": "import express from 'express';\nimport * as searchService from '../services/searchService.js';\n\nconst router = express.Router();\n\nrouter.get('/web', async (req, res, next) => {\n  try {\n    const { query, source = 'all', limit = '20', language, sortBy } = req.query;\n    if (!query) {\n      return res.status(400).json({ success: false, error: 'Query is required' });\n    }\n    \n    const options = {\n      limit: parseInt(limit as string),\n      language: language as string,\n      sortBy: sortBy as any,\n    };\n    \n    const results = await searchService.searchSource(source as string, query as string, options);\n    res.json({ success: true, data: results });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/suggestions', async (req, res, next) => {\n  try {\n    const { q } = req.query;\n    if (!q) {\n      return res.status(400).json({ success: false, error: 'Query is required' });\n    }\n    \n    const suggestions = await searchService.getSearchSuggestions(q as string);\n    res.json({ success: true, data: suggestions });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/code', async (req, res, next) => {\n  try {\n    const { query, language, limit = '10' } = req.query;\n    if (!query) {\n      return res.status(400).json({ success: false, error: 'Query is required' });\n    }\n    \n    const results = await searchService.searchCodeSnippets(query as string, language as string);\n    res.json({ success: true, data: results.slice(0, parseInt(limit as string)) });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/docs', async (req, res, next) => {\n  try {\n    const { query, framework, limit = '10' } = req.query;\n    if (!query) {\n      return res.status(400).json({ success: false, error: 'Query is required' });\n    }\n    \n    const results = await searchService.searchDocumentation(query as string, framework as string);\n    res.json({ success: true, data: results.slice(0, parseInt(limit as string)) });\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;\n\n",
    "hash": "e9b5a449d8cf3c9364a7f74257566264",
    "lastModified": "2025-10-27T08:49:22.995Z",
    "synced": false
  },
  {
    "id": "630cf4a91c0641ee23bb7b719d4c95d6",
    "type": "workspace",
    "path": "/workspace/backend/src/routes/security.ts",
    "content": "import express from 'express';\nimport * as securityService from '../services/securityService.js';\nimport * as packageService from '../services/packageService.js';\n\nconst router = express.Router();\n\nrouter.post('/scan', async (req, res, next) => {\n  try {\n    const { type = 'all' } = req.body;\n    const manager = await packageService.detectPackageManager();\n    \n    let vulnerabilities: any[] = [];\n    \n    if (type === 'dependencies' || type === 'all') {\n      const depResult = await securityService.scanDependencies(manager || 'npm');\n      vulnerabilities = [...vulnerabilities, ...depResult.vulnerabilities];\n    }\n    \n    if (type === 'code' || type === 'all') {\n      const codeVulns = await securityService.scanCodeSecurity();\n      vulnerabilities = [...vulnerabilities, ...codeVulns];\n    }\n    \n    res.json({ success: true, data: vulnerabilities });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/fix', async (req, res, next) => {\n  try {\n    const { vulnerabilityId, manager = 'npm' } = req.body;\n    if (!vulnerabilityId) {\n      return res.status(400).json({ success: false, error: 'Vulnerability ID is required' });\n    }\n    \n    await securityService.fixVulnerability(vulnerabilityId, manager);\n    res.json({ success: true, message: 'Vulnerability fix attempted' });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/cve/:cveId', async (req, res, next) => {\n  try {\n    const { cveId } = req.params;\n    const cveInfo = await securityService.getCVEInfo(cveId);\n    res.json({ success: true, data: cveInfo });\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;\n\n",
    "hash": "3064710913d5e1be98e334881e6b893f",
    "lastModified": "2025-10-27T08:49:22.995Z",
    "synced": false
  },
  {
    "id": "be803d8556348487a6f02b034adc187c",
    "type": "workspace",
    "path": "/workspace/backend/src/routes/voice.ts",
    "content": "import express from 'express';\nimport { voiceService } from '../services/voiceService.js';\n\nconst router = express.Router();\n\n// Start voice listening\nrouter.post('/start', async (req, res, next) => {\n  try {\n    const session = await voiceService.startListening();\n    res.json({ success: true, data: session });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Stop voice listening\nrouter.post('/stop', async (req, res, next) => {\n  try {\n    const { sessionId } = req.body;\n    await voiceService.stopListening(sessionId);\n    res.json({ success: true, message: 'Voice listening stopped' });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Process voice command\nrouter.post('/command', async (req, res, next) => {\n  try {\n    const { sessionId, transcript } = req.body;\n    \n    if (!sessionId || !transcript) {\n      return res.status(400).json({ \n        success: false, \n        error: 'Session ID and transcript are required' \n      });\n    }\n    \n    await voiceService.processVoiceCommand(sessionId, transcript);\n    res.json({ success: true, message: 'Command processed' });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get voice configuration\nrouter.get('/config', async (req, res, next) => {\n  try {\n    const config = voiceService.getConfig();\n    res.json({ success: true, data: config });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Update voice configuration\nrouter.put('/config', async (req, res, next) => {\n  try {\n    const config = req.body;\n    await voiceService.updateConfig(config);\n    res.json({ success: true, message: 'Configuration updated' });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Add voice command\nrouter.post('/commands', async (req, res, next) => {\n  try {\n    const command = req.body;\n    await voiceService.addCommand(command);\n    res.json({ success: true, message: 'Command added' });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Remove voice command\nrouter.delete('/commands/:id', async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    await voiceService.removeCommand(id);\n    res.json({ success: true, message: 'Command removed' });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get active sessions\nrouter.get('/sessions', async (req, res, next) => {\n  try {\n    const sessions = voiceService.getSessions();\n    res.json({ success: true, data: sessions });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get current session\nrouter.get('/sessions/current', async (req, res, next) => {\n  try {\n    const session = voiceService.getCurrentSession();\n    res.json({ success: true, data: session });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Check if voice is active\nrouter.get('/status', async (req, res, next) => {\n  try {\n    const isActive = voiceService.isVoiceActive();\n    res.json({ success: true, data: { isActive } });\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;",
    "hash": "0bf5f5ec5eee1b3b561eaa7081250b79",
    "lastModified": "2025-10-27T08:49:22.995Z",
    "synced": false
  },
  {
    "id": "13a7e51fe00e91b759c48de2ebae9abb",
    "type": "workspace",
    "path": "/workspace/backend/src/server.ts",
    "content": "import express from 'express';\nimport cors from 'cors';\nimport http from 'http';\nimport { Server as SocketIOServer } from 'socket.io';\nimport dotenv from 'dotenv';\n\n// API Routes\nimport filesRouter from './routes/files.js';\nimport ollamaRouter from './routes/ollama.js';\nimport gitRouter from './routes/git.js';\nimport packagesRouter from './routes/packages.js';\nimport securityRouter from './routes/security.js';\nimport mediaRouter from './routes/media.js';\nimport deploymentRouter from './routes/deployment.js';\nimport searchRouter from './routes/search.js';\nimport performanceRouter from './routes/performance.js';\nimport databaseRouter from './routes/database.js';\nimport agentRouter from './routes/agent.js';\nimport pluginsRouter from './routes/plugins.js';\nimport voiceRouter from './routes/voice.js';\nimport cloudSyncRouter from './routes/cloudSync.js';\nimport authRouter from './routes/auth.js';\nimport debugRouter from './routes/debug.js';\n\n// Services\nimport { setupTerminalHandlers } from './services/terminalService.js';\nimport { setupOllamaHandlers } from './services/ollamaService.js';\n\ndotenv.config();\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = new SocketIOServer(server, {\n  cors: {\n    origin: '*', // Allow all origins in development\n    methods: ['GET', 'POST'],\n  },\n});\n\nconst PORT = process.env.PORT || 3001;\n\n// Middleware configuration\napp.use(cors()); // Enable CORS for all routes\napp.use(express.json({ limit: '50mb' })); // Support large file uploads\napp.use(express.urlencoded({ extended: true, limit: '50mb' }));\n\n// API Routes registration\napp.use('/api/files', filesRouter);\napp.use('/api/ollama', ollamaRouter);\napp.use('/api/git', gitRouter);\napp.use('/api/packages', packagesRouter);\napp.use('/api/security', securityRouter);\napp.use('/api/media', mediaRouter);\napp.use('/api/deployment', deploymentRouter);\napp.use('/api/search', searchRouter);\napp.use('/api/performance', performanceRouter);\napp.use('/api/database', databaseRouter);\napp.use('/api/agent', agentRouter);\napp.use('/api/plugins', pluginsRouter);\napp.use('/api/voice', voiceRouter);\napp.use('/api/cloud-sync', cloudSyncRouter);\napp.use('/api/auth', authRouter);\napp.use('/api/debug', debugRouter);\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n  res.json({ status: 'ok', timestamp: new Date().toISOString() });\n});\n\n// WebSocket connection handling\nio.on('connection', (socket) => {\n  console.log(`[WebSocket] Client connected: ${socket.id}`);\n  \n  // Setup handlers for different features\n  setupTerminalHandlers(socket);\n  setupOllamaHandlers(socket, io);\n\n  socket.on('disconnect', () => {\n    console.log(`[WebSocket] Client disconnected: ${socket.id}`);\n  });\n\n  socket.on('error', (error) => {\n    console.error(`[WebSocket] Error for ${socket.id}:`, error);\n  });\n});\n\n// Global error handling middleware\napp.use((err: any, req: express.Request, res: express.Response, next: express.NextFunction) => {\n  console.error('[Error]', err);\n  res.status(500).json({\n    success: false,\n    error: err.message || 'Internal server error',\n  });\n});\n\n// Start server with detailed startup information\nserver.listen(PORT, () => {\n  console.log(`\n\n   Tantra IDE Backend Server Started    \n\n  Port: ${PORT.toString().padEnd(33)}\n  Environment: ${(process.env.NODE_ENV || 'development').padEnd(26)}\n  Time: ${new Date().toLocaleTimeString().padEnd(33)}\n\n  `);\n  \n  console.log(' API Routes:');\n  console.log(`   - Files:      http://localhost:${PORT}/api/files`);\n  console.log(`   - Ollama:     http://localhost:${PORT}/api/ollama`);\n  console.log(`   - Git:        http://localhost:${PORT}/api/git`);\n  console.log(`   - Packages:   http://localhost:${PORT}/api/packages`);\n  console.log(`   - Security:   http://localhost:${PORT}/api/security`);\n  console.log(`   - Media:      http://localhost:${PORT}/api/media`);\n  console.log(`   - Deployment: http://localhost:${PORT}/api/deployment`);\n  console.log(`   - Search:     http://localhost:${PORT}/api/search`);\n  console.log(`   - Performance: http://localhost:${PORT}/api/performance`);\n  console.log(`   - Database:   http://localhost:${PORT}/api/database`);\n  console.log(`   - Agent:      http://localhost:${PORT}/api/agent`);\n  console.log('');\n  console.log(' WebSocket: Connected');\n  console.log('');\n});\n\n// Graceful shutdown handling\nprocess.on('SIGTERM', () => {\n  console.log('SIGTERM received, shutting down gracefully');\n  server.close(() => {\n    console.log('Server closed');\n    process.exit(0);\n  });\n});\n\nprocess.on('SIGINT', () => {\n  console.log('\\nSIGINT received, shutting down gracefully');\n  server.close(() => {\n    console.log('Server closed');\n    process.exit(0);\n  });\n});\n\nexport { io };\n\n",
    "hash": "607601b26e0b8ec0c249b27803bf2377",
    "lastModified": "2025-10-27T08:27:34.510Z",
    "synced": false
  },
  {
    "id": "abdadc6f06d0e44778d8493d46f0cca2",
    "type": "workspace",
    "path": "/workspace/backend/src/services/agentService.ts",
    "content": "import { exec } from 'child_process';\nimport { promisify } from 'util';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport axios from 'axios';\n\nconst execAsync = promisify(exec);\nconst WORKSPACE_PATH = process.env.WORKSPACE_PATH || process.cwd();\nconst OLLAMA_URL = process.env.OLLAMA_URL || 'http://localhost:11434';\n\nexport interface Task {\n  id: string;\n  title: string;\n  description: string;\n  status: 'pending' | 'in_progress' | 'completed' | 'failed' | 'cancelled';\n  priority: 'low' | 'medium' | 'high' | 'critical';\n  type: 'code' | 'file' | 'git' | 'deploy' | 'test' | 'research' | 'other';\n  subtasks: Task[];\n  dependencies: string[];\n  estimatedDuration: number; // in minutes\n  actualDuration?: number;\n  createdAt: Date;\n  updatedAt: Date;\n  completedAt?: Date;\n  assignedTo?: string;\n  tags: string[];\n  context?: any;\n  result?: any;\n  error?: string;\n}\n\nexport interface TaskPlan {\n  id: string;\n  goal: string;\n  description: string;\n  tasks: Task[];\n  status: 'planning' | 'ready' | 'executing' | 'completed' | 'failed';\n  createdAt: Date;\n  updatedAt: Date;\n  completedAt?: Date;\n  totalEstimatedDuration: number;\n  totalActualDuration?: number;\n}\n\nexport interface AgentContext {\n  currentFile?: string;\n  projectType?: string;\n  gitBranch?: string;\n  recentChanges?: string[];\n  dependencies?: string[];\n  environment?: string;\n}\n\n// Task Planning\nexport async function createTaskPlan(goal: string, context?: AgentContext): Promise<TaskPlan> {\n  try {\n    // Use AI to break down the goal into tasks\n    const tasks = await generateTasksFromGoal(goal, context);\n    \n    const plan: TaskPlan = {\n      id: `plan-${Date.now()}`,\n      goal,\n      description: `Plan to achieve: ${goal}`,\n      tasks,\n      status: 'ready',\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      totalEstimatedDuration: tasks.reduce((sum, task) => sum + task.estimatedDuration, 0),\n    };\n    \n    return plan;\n  } catch (error) {\n    console.error('Task plan creation error:', error);\n    throw error;\n  }\n}\n\nasync function generateTasksFromGoal(goal: string, context?: AgentContext): Promise<Task[]> {\n  try {\n    const prompt = `\nYou are an AI task planner. Break down the following goal into specific, actionable tasks:\n\nGoal: ${goal}\n\nContext:\n${context ? JSON.stringify(context, null, 2) : 'No specific context provided'}\n\nPlease create a detailed task breakdown with:\n1. Specific, actionable tasks\n2. Estimated duration for each task (in minutes)\n3. Task dependencies\n4. Priority levels\n5. Task types\n\nReturn the tasks as a JSON array with this structure:\n[\n  {\n    \"title\": \"Task title\",\n    \"description\": \"Detailed description\",\n    \"type\": \"code|file|git|deploy|test|research|other\",\n    \"priority\": \"low|medium|high|critical\",\n    \"estimatedDuration\": 30,\n    \"dependencies\": [],\n    \"tags\": [\"tag1\", \"tag2\"]\n  }\n]\n`;\n\n    const response = await axios.post(`${OLLAMA_URL}/api/generate`, {\n      model: 'qwen2.5-coder:7b',\n      prompt,\n      stream: false,\n    });\n\n    const tasksText = response.data.response;\n    \n    // Extract JSON from the response\n    const jsonMatch = tasksText.match(/\\[[\\s\\S]*\\]/);\n    if (!jsonMatch) {\n      throw new Error('Could not parse task JSON from AI response');\n    }\n\n    const tasksData = JSON.parse(jsonMatch[0]);\n    \n    return tasksData.map((taskData: any, index: number) => ({\n      id: `task-${Date.now()}-${index}`,\n      title: taskData.title,\n      description: taskData.description,\n      status: 'pending' as const,\n      priority: taskData.priority,\n      type: taskData.type,\n      subtasks: [],\n      dependencies: taskData.dependencies || [],\n      estimatedDuration: taskData.estimatedDuration,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      tags: taskData.tags || [],\n    }));\n  } catch (error) {\n    console.error('Task generation error:', error);\n    // Fallback to basic task creation\n    return [{\n      id: `task-${Date.now()}`,\n      title: goal,\n      description: `Complete: ${goal}`,\n      status: 'pending' as const,\n      priority: 'medium' as const,\n      type: 'other' as const,\n      subtasks: [],\n      dependencies: [],\n      estimatedDuration: 60,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      tags: [],\n    }];\n  }\n}\n\n// Task Execution\nexport async function executeTask(task: Task, context?: AgentContext): Promise<Task> {\n  const startTime = Date.now();\n  \n  try {\n    task.status = 'in_progress';\n    task.updatedAt = new Date();\n    \n    // Execute based on task type\n    let result: any;\n    \n    switch (task.type) {\n      case 'code':\n        result = await executeCodeTask(task, context);\n        break;\n      case 'file':\n        result = await executeFileTask(task, context);\n        break;\n      case 'git':\n        result = await executeGitTask(task, context);\n        break;\n      case 'deploy':\n        result = await executeDeployTask(task, context);\n        break;\n      case 'test':\n        result = await executeTestTask(task, context);\n        break;\n      case 'research':\n        result = await executeResearchTask(task, context);\n        break;\n      default:\n        result = await executeGenericTask(task, context);\n    }\n    \n    task.status = 'completed';\n    task.result = result;\n    task.actualDuration = Math.round((Date.now() - startTime) / 1000 / 60); // minutes\n    task.completedAt = new Date();\n    \n  } catch (error: any) {\n    task.status = 'failed';\n    task.error = error.message;\n    task.actualDuration = Math.round((Date.now() - startTime) / 1000 / 60);\n  }\n  \n  task.updatedAt = new Date();\n  return task;\n}\n\nasync function executeCodeTask(task: Task, context?: AgentContext): Promise<any> {\n  // Use AI to generate or modify code\n  const prompt = `\nYou are an AI coding assistant. Please help with this task:\n\nTask: ${task.title}\nDescription: ${task.description}\n\nContext:\n${context ? JSON.stringify(context, null, 2) : 'No specific context'}\n\nPlease provide:\n1. The code solution\n2. Explanation of the approach\n3. Any additional files that need to be created or modified\n\nReturn your response in a structured format.\n`;\n\n  const response = await axios.post(`${OLLAMA_URL}/api/generate`, {\n    model: 'qwen2.5-coder:7b',\n    prompt,\n    stream: false,\n  });\n\n  return {\n    type: 'code_generation',\n    content: response.data.response,\n    timestamp: new Date().toISOString(),\n  };\n}\n\nasync function executeFileTask(task: Task, context?: AgentContext): Promise<any> {\n  // Handle file operations\n  const filePath = extractFilePathFromTask(task);\n  \n  if (task.title.toLowerCase().includes('create')) {\n    await fs.writeFile(filePath, '');\n    return { type: 'file_created', path: filePath };\n  } else if (task.title.toLowerCase().includes('delete')) {\n    await fs.unlink(filePath);\n    return { type: 'file_deleted', path: filePath };\n  } else if (task.title.toLowerCase().includes('read')) {\n    const content = await fs.readFile(filePath, 'utf-8');\n    return { type: 'file_read', path: filePath, content };\n  }\n  \n  return { type: 'file_operation', path: filePath };\n}\n\nasync function executeGitTask(task: Task, context?: AgentContext): Promise<any> {\n  const commands = extractGitCommandsFromTask(task);\n  const results: any[] = [];\n  \n  for (const command of commands) {\n    try {\n      const { stdout } = await execAsync(command, { cwd: WORKSPACE_PATH });\n      results.push({ command, output: stdout, success: true });\n    } catch (error: any) {\n      results.push({ command, error: error.message, success: false });\n    }\n  }\n  \n  return { type: 'git_operations', results };\n}\n\nasync function executeDeployTask(task: Task, context?: AgentContext): Promise<any> {\n  // Handle deployment tasks\n  const deploymentType = extractDeploymentTypeFromTask(task);\n  \n  // This would integrate with the deployment service\n  return {\n    type: 'deployment',\n    deploymentType,\n    status: 'completed',\n    timestamp: new Date().toISOString(),\n  };\n}\n\nasync function executeTestTask(task: Task, context?: AgentContext): Promise<any> {\n  // Run tests\n  const testCommand = await detectTestCommand();\n  \n  try {\n    const { stdout } = await execAsync(testCommand, { cwd: WORKSPACE_PATH });\n    return {\n      type: 'test_execution',\n      command: testCommand,\n      output: stdout,\n      success: true,\n    };\n  } catch (error: any) {\n    return {\n      type: 'test_execution',\n      command: testCommand,\n      error: error.message,\n      success: false,\n    };\n  }\n}\n\nasync function executeResearchTask(task: Task, context?: AgentContext): Promise<any> {\n  // Use search capabilities to research\n  const searchQuery = extractSearchQueryFromTask(task);\n  \n  // This would integrate with the search service\n  return {\n    type: 'research',\n    query: searchQuery,\n    results: 'Research results would be fetched here',\n    timestamp: new Date().toISOString(),\n  };\n}\n\nasync function executeGenericTask(task: Task, context?: AgentContext): Promise<any> {\n  // Generic task execution using AI\n  const prompt = `\nPlease help complete this task:\n\nTask: ${task.title}\nDescription: ${task.description}\n\nProvide a detailed response on how to complete this task.\n`;\n\n  const response = await axios.post(`${OLLAMA_URL}/api/generate`, {\n    model: 'qwen2.5-coder:7b',\n    prompt,\n    stream: false,\n  });\n\n  return {\n    type: 'generic_task',\n    content: response.data.response,\n    timestamp: new Date().toISOString(),\n  };\n}\n\n// Helper functions\nfunction extractFilePathFromTask(task: Task): string {\n  // Extract file path from task description\n  const pathMatch = task.description.match(/['\"]([^'\"]*\\.\\w+)['\"]/);\n  return pathMatch ? pathMatch[1] : 'unknown.txt';\n}\n\nfunction extractGitCommandsFromTask(task: Task): string[] {\n  const commands: string[] = [];\n  \n  if (task.title.toLowerCase().includes('commit')) {\n    commands.push('git add .');\n    commands.push('git commit -m \"Auto-commit from task execution\"');\n  }\n  \n  if (task.title.toLowerCase().includes('push')) {\n    commands.push('git push');\n  }\n  \n  if (task.title.toLowerCase().includes('pull')) {\n    commands.push('git pull');\n  }\n  \n  return commands;\n}\n\nfunction extractDeploymentTypeFromTask(task: Task): string {\n  if (task.title.toLowerCase().includes('vercel')) return 'vercel';\n  if (task.title.toLowerCase().includes('netlify')) return 'netlify';\n  if (task.title.toLowerCase().includes('aws')) return 'aws';\n  return 'unknown';\n}\n\nfunction extractSearchQueryFromTask(task: Task): string {\n  // Extract search terms from task description\n  return task.description.split(' ').slice(0, 5).join(' ');\n}\n\nasync function detectTestCommand(): Promise<string> {\n  // Detect test command based on project type\n  try {\n    // Check for package.json\n    const packageJsonPath = path.join(WORKSPACE_PATH, 'package.json');\n    await fs.access(packageJsonPath);\n    return 'npm test';\n  } catch {\n    return 'echo \"No test command detected\"';\n  }\n}\n\n// Plan Execution\nexport async function executeTaskPlan(plan: TaskPlan): Promise<TaskPlan> {\n  plan.status = 'executing';\n  plan.updatedAt = new Date();\n  \n  const startTime = Date.now();\n  \n  try {\n    // Execute tasks in dependency order\n    const executedTasks = new Set<string>();\n    const taskMap = new Map(plan.tasks.map(task => [task.id, task]));\n    \n    while (executedTasks.size < plan.tasks.length) {\n      let progressMade = false;\n      \n      for (const task of plan.tasks) {\n        if (executedTasks.has(task.id)) continue;\n        \n        // Check if dependencies are met\n        const dependenciesMet = task.dependencies.every(depId => executedTasks.has(depId));\n        \n        if (dependenciesMet) {\n          const updatedTask = await executeTask(task);\n          taskMap.set(task.id, updatedTask);\n          executedTasks.add(task.id);\n          progressMade = true;\n          \n          // Update the task in the plan\n          const taskIndex = plan.tasks.findIndex(t => t.id === task.id);\n          if (taskIndex !== -1) {\n            plan.tasks[taskIndex] = updatedTask;\n          }\n        }\n      }\n      \n      if (!progressMade) {\n        // Circular dependency or error\n        plan.status = 'failed';\n        break;\n      }\n    }\n    \n    if (plan.status !== 'failed') {\n      plan.status = 'completed';\n      plan.completedAt = new Date();\n    }\n    \n    plan.totalActualDuration = Math.round((Date.now() - startTime) / 1000 / 60);\n    plan.updatedAt = new Date();\n    \n  } catch (error: any) {\n    plan.status = 'failed';\n    plan.updatedAt = new Date();\n  }\n  \n  return plan;\n}\n\n// Task Management\nexport async function getTaskPlans(): Promise<TaskPlan[]> {\n  // In a real implementation, this would read from a database\n  return [];\n}\n\nexport async function saveTaskPlan(plan: TaskPlan): Promise<void> {\n  // In a real implementation, this would save to a database\n  console.log('Saving task plan:', plan.id);\n}\n\nexport async function getTaskPlan(id: string): Promise<TaskPlan | null> {\n  // In a real implementation, this would read from a database\n  return null;\n}\n\n// Agent Context Management\nexport async function getAgentContext(): Promise<AgentContext> {\n  try {\n    const context: AgentContext = {};\n    \n    // Get current Git branch\n    try {\n      const { stdout } = await execAsync('git branch --show-current', { cwd: WORKSPACE_PATH });\n      context.gitBranch = stdout.trim();\n    } catch {\n      // Not a git repository\n    }\n    \n    // Get recent changes\n    try {\n      const { stdout } = await execAsync('git log --oneline -5', { cwd: WORKSPACE_PATH });\n      context.recentChanges = stdout.split('\\n').filter(line => line.trim());\n    } catch {\n      // No git history\n    }\n    \n    // Detect project type\n    try {\n      const packageJsonPath = path.join(WORKSPACE_PATH, 'package.json');\n      await fs.access(packageJsonPath);\n      const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf-8'));\n      \n      if (packageJson.dependencies?.react) {\n        context.projectType = 'react';\n      } else if (packageJson.dependencies?.vue) {\n        context.projectType = 'vue';\n      } else if (packageJson.dependencies?.next) {\n        context.projectType = 'nextjs';\n      } else {\n        context.projectType = 'node';\n      }\n      \n      context.dependencies = Object.keys(packageJson.dependencies || {});\n    } catch {\n      context.projectType = 'unknown';\n    }\n    \n    return context;\n  } catch (error) {\n    console.error('Error getting agent context:', error);\n    return {};\n  }\n}\n\n",
    "hash": "6e7e721da6a24e9aed425898e0122956",
    "lastModified": "2025-10-27T08:50:24.098Z",
    "synced": false
  },
  {
    "id": "59c1704236b547d3d6897b0c2f220c33",
    "type": "workspace",
    "path": "/workspace/backend/src/services/authService.ts",
    "content": "import crypto from 'crypto';\nimport jwt from 'jsonwebtoken';\nimport bcrypt from 'bcrypt';\nimport fs from 'fs/promises';\nimport path from 'path';\n\nexport interface User {\n  id: string;\n  username: string;\n  email: string;\n  passwordHash: string;\n  role: 'admin' | 'user' | 'guest';\n  permissions: string[];\n  createdAt: Date;\n  lastLogin?: Date;\n  isActive: boolean;\n  preferences: UserPreferences;\n}\n\nexport interface UserPreferences {\n  theme: 'light' | 'dark' | 'auto';\n  fontSize: number;\n  tabSize: number;\n  autoSave: boolean;\n  notifications: boolean;\n  language: string;\n}\n\nexport interface AuthSession {\n  id: string;\n  userId: string;\n  token: string;\n  refreshToken: string;\n  expiresAt: Date;\n  createdAt: Date;\n  lastActivity: Date;\n  ipAddress: string;\n  userAgent: string;\n  isActive: boolean;\n}\n\nexport interface AuthConfig {\n  jwtSecret: string;\n  jwtExpiresIn: string;\n  refreshTokenExpiresIn: string;\n  bcryptRounds: number;\n  maxSessions: number;\n  sessionTimeout: number; // in minutes\n}\n\nclass AuthService {\n  private users: Map<string, User> = new Map();\n  private sessions: Map<string, AuthSession> = new Map();\n  private config: AuthConfig;\n  private dataDir: string;\n\n  constructor() {\n    this.dataDir = path.join(process.cwd(), '.tantra', 'auth');\n    this.config = {\n      jwtSecret: process.env.JWT_SECRET || crypto.randomBytes(64).toString('hex'),\n      jwtExpiresIn: '1h',\n      refreshTokenExpiresIn: '7d',\n      bcryptRounds: 12,\n      maxSessions: 5,\n      sessionTimeout: 60,\n    };\n    \n    this.initializeAuth();\n  }\n\n  private async initializeAuth(): Promise<void> {\n    try {\n      await fs.mkdir(this.dataDir, { recursive: true });\n      await this.loadUsers();\n      await this.loadSessions();\n      \n      // Create default admin user if no users exist\n      if (this.users.size === 0) {\n        await this.createDefaultAdmin();\n      }\n    } catch (error) {\n      console.error('[Auth] Initialization error:', error);\n    }\n  }\n\n  private async loadUsers(): Promise<void> {\n    try {\n      const usersPath = path.join(this.dataDir, 'users.json');\n      const usersData = await fs.readFile(usersPath, 'utf-8');\n      const users: User[] = JSON.parse(usersData);\n      \n      this.users.clear();\n      for (const user of users) {\n        this.users.set(user.id, user);\n      }\n    } catch (error) {\n      // Users file doesn't exist yet\n    }\n  }\n\n  private async saveUsers(): Promise<void> {\n    try {\n      const usersPath = path.join(this.dataDir, 'users.json');\n      const users = Array.from(this.users.values());\n      await fs.writeFile(usersPath, JSON.stringify(users, null, 2));\n    } catch (error) {\n      console.error('[Auth] Failed to save users:', error);\n    }\n  }\n\n  private async loadSessions(): Promise<void> {\n    try {\n      const sessionsPath = path.join(this.dataDir, 'sessions.json');\n      const sessionsData = await fs.readFile(sessionsPath, 'utf-8');\n      const sessions: AuthSession[] = JSON.parse(sessionsData);\n      \n      this.sessions.clear();\n      for (const session of sessions) {\n        if (session.isActive && new Date(session.expiresAt) > new Date()) {\n          this.sessions.set(session.id, session);\n        }\n      }\n    } catch (error) {\n      // Sessions file doesn't exist yet\n    }\n  }\n\n  private async saveSessions(): Promise<void> {\n    try {\n      const sessionsPath = path.join(this.dataDir, 'sessions.json');\n      const sessions = Array.from(this.sessions.values());\n      await fs.writeFile(sessionsPath, JSON.stringify(sessions, null, 2));\n    } catch (error) {\n      console.error('[Auth] Failed to save sessions:', error);\n    }\n  }\n\n  private async createDefaultAdmin(): Promise<void> {\n    const adminUser: User = {\n      id: crypto.randomUUID(),\n      username: 'admin',\n      email: 'admin@tantra-ide.dev',\n      passwordHash: await bcrypt.hash('admin123', this.config.bcryptRounds),\n      role: 'admin',\n      permissions: ['*'], // All permissions\n      createdAt: new Date(),\n      isActive: true,\n      preferences: {\n        theme: 'dark',\n        fontSize: 14,\n        tabSize: 2,\n        autoSave: true,\n        notifications: true,\n        language: 'en',\n      },\n    };\n    \n    this.users.set(adminUser.id, adminUser);\n    await this.saveUsers();\n    \n    console.log('[Auth] Default admin user created (username: admin, password: admin123)');\n  }\n\n  async register(username: string, email: string, password: string): Promise<User> {\n    // Check if user already exists\n    const existingUser = Array.from(this.users.values()).find(\n      user => user.username === username || user.email === email\n    );\n    \n    if (existingUser) {\n      throw new Error('User already exists');\n    }\n    \n    // Validate password strength\n    if (password.length < 8) {\n      throw new Error('Password must be at least 8 characters long');\n    }\n    \n    const passwordHash = await bcrypt.hash(password, this.config.bcryptRounds);\n    \n    const user: User = {\n      id: crypto.randomUUID(),\n      username,\n      email,\n      passwordHash,\n      role: 'user',\n      permissions: ['read', 'write', 'execute'],\n      createdAt: new Date(),\n      isActive: true,\n      preferences: {\n        theme: 'dark',\n        fontSize: 14,\n        tabSize: 2,\n        autoSave: true,\n        notifications: true,\n        language: 'en',\n      },\n    };\n    \n    this.users.set(user.id, user);\n    await this.saveUsers();\n    \n    return user;\n  }\n\n  async login(username: string, password: string, ipAddress: string, userAgent: string): Promise<{ user: User; session: AuthSession }> {\n    const user = Array.from(this.users.values()).find(\n      u => u.username === username || u.email === username\n    );\n    \n    if (!user || !user.isActive) {\n      throw new Error('Invalid credentials');\n    }\n    \n    const isValidPassword = await bcrypt.compare(password, user.passwordHash);\n    if (!isValidPassword) {\n      throw new Error('Invalid credentials');\n    }\n    \n    // Clean up old sessions for this user\n    await this.cleanupUserSessions(user.id);\n    \n    // Create new session\n    const session = await this.createSession(user.id, ipAddress, userAgent);\n    \n    // Update last login\n    user.lastLogin = new Date();\n    await this.saveUsers();\n    \n    return { user, session };\n  }\n\n  async logout(sessionId: string): Promise<void> {\n    const session = this.sessions.get(sessionId);\n    if (session) {\n      session.isActive = false;\n      this.sessions.delete(sessionId);\n      await this.saveSessions();\n    }\n  }\n\n  async logoutAll(userId: string): Promise<void> {\n    const userSessions = Array.from(this.sessions.values()).filter(\n      session => session.userId === userId\n    );\n    \n    for (const session of userSessions) {\n      session.isActive = false;\n      this.sessions.delete(session.id);\n    }\n    \n    await this.saveSessions();\n  }\n\n  private async createSession(userId: string, ipAddress: string, userAgent: string): Promise<AuthSession> {\n    const token = jwt.sign(\n      { userId, type: 'access' },\n      this.config.jwtSecret,\n      { expiresIn: this.config.jwtExpiresIn } as any\n    );\n    \n    const refreshToken = jwt.sign(\n      { userId, type: 'refresh' },\n      this.config.jwtSecret,\n      { expiresIn: this.config.refreshTokenExpiresIn } as any\n    );\n    \n    const session: AuthSession = {\n      id: crypto.randomUUID(),\n      userId,\n      token,\n      refreshToken,\n      expiresAt: new Date(Date.now() + 60 * 60 * 1000), // 1 hour\n      createdAt: new Date(),\n      lastActivity: new Date(),\n      ipAddress,\n      userAgent,\n      isActive: true,\n    };\n    \n    this.sessions.set(session.id, session);\n    await this.saveSessions();\n    \n    return session;\n  }\n\n  private async cleanupUserSessions(userId: string): Promise<void> {\n    const userSessions = Array.from(this.sessions.values()).filter(\n      session => session.userId === userId\n    );\n    \n    // Remove oldest sessions if exceeding max\n    if (userSessions.length >= this.config.maxSessions) {\n      const sortedSessions = userSessions.sort(\n        (a, b) => a.createdAt.getTime() - b.createdAt.getTime()\n      );\n      \n      const sessionsToRemove = sortedSessions.slice(0, userSessions.length - this.config.maxSessions + 1);\n      for (const session of sessionsToRemove) {\n        session.isActive = false;\n        this.sessions.delete(session.id);\n      }\n    }\n  }\n\n  async validateToken(token: string): Promise<{ user: User; session: AuthSession } | null> {\n    try {\n      const decoded = jwt.verify(token, this.config.jwtSecret) as any;\n      \n      if (decoded.type !== 'access') {\n        return null;\n      }\n      \n      const session = Array.from(this.sessions.values()).find(\n        s => s.token === token && s.isActive\n      );\n      \n      if (!session || new Date(session.expiresAt) <= new Date()) {\n        return null;\n      }\n      \n      const user = this.users.get(session.userId);\n      if (!user || !user.isActive) {\n        return null;\n      }\n      \n      // Update last activity\n      session.lastActivity = new Date();\n      await this.saveSessions();\n      \n      return { user, session };\n    } catch (error) {\n      return null;\n    }\n  }\n\n  async refreshToken(refreshToken: string): Promise<{ token: string; session: AuthSession } | null> {\n    try {\n      const decoded = jwt.verify(refreshToken, this.config.jwtSecret) as any;\n      \n      if (decoded.type !== 'refresh') {\n        return null;\n      }\n      \n      const session = Array.from(this.sessions.values()).find(\n        s => s.refreshToken === refreshToken && s.isActive\n      );\n      \n      if (!session || new Date(session.expiresAt) <= new Date()) {\n        return null;\n      }\n      \n      // Generate new access token\n      const newToken = jwt.sign(\n        { userId: session.userId, type: 'access' },\n        this.config.jwtSecret,\n        { expiresIn: this.config.jwtExpiresIn } as any\n      );\n      \n      session.token = newToken;\n      session.lastActivity = new Date();\n      await this.saveSessions();\n      \n      return { token: newToken, session };\n    } catch (error) {\n      return null;\n    }\n  }\n\n  async updateUserPreferences(userId: string, preferences: Partial<UserPreferences>): Promise<void> {\n    const user = this.users.get(userId);\n    if (user) {\n      user.preferences = { ...user.preferences, ...preferences };\n      await this.saveUsers();\n    }\n  }\n\n  async changePassword(userId: string, currentPassword: string, newPassword: string): Promise<void> {\n    const user = this.users.get(userId);\n    if (!user) {\n      throw new Error('User not found');\n    }\n    \n    const isValidPassword = await bcrypt.compare(currentPassword, user.passwordHash);\n    if (!isValidPassword) {\n      throw new Error('Current password is incorrect');\n    }\n    \n    if (newPassword.length < 8) {\n      throw new Error('New password must be at least 8 characters long');\n    }\n    \n    user.passwordHash = await bcrypt.hash(newPassword, this.config.bcryptRounds);\n    await this.saveUsers();\n  }\n\n  async getUser(userId: string): Promise<User | null> {\n    return this.users.get(userId) || null;\n  }\n\n  async getAllUsers(): Promise<User[]> {\n    return Array.from(this.users.values());\n  }\n\n  async getActiveSessions(): Promise<AuthSession[]> {\n    return Array.from(this.sessions.values()).filter(session => session.isActive);\n  }\n\n  async hasPermission(userId: string, permission: string): Promise<boolean> {\n    const user = this.users.get(userId);\n    if (!user || !user.isActive) {\n      return false;\n    }\n    \n    return user.permissions.includes('*') || user.permissions.includes(permission);\n  }\n\n  async cleanupExpiredSessions(): Promise<void> {\n    const now = new Date();\n    const expiredSessions = Array.from(this.sessions.values()).filter(\n      session => new Date(session.expiresAt) <= now\n    );\n    \n    for (const session of expiredSessions) {\n      session.isActive = false;\n      this.sessions.delete(session.id);\n    }\n    \n    if (expiredSessions.length > 0) {\n      await this.saveSessions();\n    }\n  }\n}\n\nexport const authService = new AuthService();",
    "hash": "ea75d473cf096737af9758fbc5113d96",
    "lastModified": "2025-10-27T08:49:04.739Z",
    "synced": false
  },
  {
    "id": "03679a13b6fb0321a04231ebbad9f496",
    "type": "workspace",
    "path": "/workspace/backend/src/services/cloudSyncService.ts",
    "content": "import fs from 'fs/promises';\nimport path from 'path';\nimport crypto from 'crypto';\nimport axios from 'axios';\n\nexport interface SyncConfig {\n  enabled: boolean;\n  provider: 'local' | 'github' | 'gitlab' | 'custom';\n  repository?: string;\n  token?: string;\n  branch: string;\n  autoSync: boolean;\n  syncInterval: number; // in minutes\n  lastSync?: Date;\n}\n\nexport interface SyncItem {\n  id: string;\n  type: 'settings' | 'workspace' | 'plugins' | 'themes';\n  path: string;\n  content: string;\n  hash: string;\n  lastModified: Date;\n  synced: boolean;\n}\n\nexport interface SyncStatus {\n  isOnline: boolean;\n  lastSync?: Date;\n  pendingChanges: number;\n  conflicts: number;\n  provider: string;\n}\n\nclass CloudSyncService {\n  private config: SyncConfig;\n  private syncItems: Map<string, SyncItem> = new Map();\n  private syncInterval: NodeJS.Timeout | null = null;\n  private isOnline: boolean = false;\n\n  constructor() {\n    this.config = {\n      enabled: false,\n      provider: 'local',\n      branch: 'main',\n      autoSync: true,\n      syncInterval: 5,\n    };\n    \n    this.initializeSync();\n  }\n\n  private async initializeSync(): Promise<void> {\n    try {\n      await this.loadConfig();\n      await this.loadSyncItems();\n      \n      if (this.config.enabled && this.config.autoSync) {\n        this.startAutoSync();\n      }\n    } catch (error) {\n      console.error('[CloudSync] Initialization error:', error);\n    }\n  }\n\n  private async loadConfig(): Promise<void> {\n    try {\n      const configPath = path.join(process.cwd(), '.tantra', 'sync-config.json');\n      const configData = await fs.readFile(configPath, 'utf-8');\n      this.config = { ...this.config, ...JSON.parse(configData) };\n    } catch (error) {\n      // Config doesn't exist, use defaults\n      await this.saveConfig();\n    }\n  }\n\n  private async saveConfig(): Promise<void> {\n    try {\n      const configDir = path.join(process.cwd(), '.tantra');\n      await fs.mkdir(configDir, { recursive: true });\n      \n      const configPath = path.join(configDir, 'sync-config.json');\n      await fs.writeFile(configPath, JSON.stringify(this.config, null, 2));\n    } catch (error) {\n      console.error('[CloudSync] Failed to save config:', error);\n    }\n  }\n\n  private async loadSyncItems(): Promise<void> {\n    try {\n      const itemsPath = path.join(process.cwd(), '.tantra', 'sync-items.json');\n      const itemsData = await fs.readFile(itemsPath, 'utf-8');\n      const items: SyncItem[] = JSON.parse(itemsData);\n      \n      this.syncItems.clear();\n      for (const item of items) {\n        this.syncItems.set(item.id, item);\n      }\n    } catch (error) {\n      // Items don't exist, start fresh\n      await this.scanWorkspace();\n    }\n  }\n\n  private async saveSyncItems(): Promise<void> {\n    try {\n      const itemsPath = path.join(process.cwd(), '.tantra', 'sync-items.json');\n      const items = Array.from(this.syncItems.values());\n      await fs.writeFile(itemsPath, JSON.stringify(items, null, 2));\n    } catch (error) {\n      console.error('[CloudSync] Failed to save sync items:', error);\n    }\n  }\n\n  async enableSync(provider: string, repository?: string, token?: string): Promise<void> {\n    this.config.enabled = true;\n    this.config.provider = provider as any;\n    this.config.repository = repository;\n    this.config.token = token;\n    \n    await this.saveConfig();\n    await this.scanWorkspace();\n    \n    if (this.config.autoSync) {\n      this.startAutoSync();\n    }\n  }\n\n  async disableSync(): Promise<void> {\n    this.config.enabled = false;\n    await this.saveConfig();\n    this.stopAutoSync();\n  }\n\n  async updateConfig(config: Partial<SyncConfig>): Promise<void> {\n    this.config = { ...this.config, ...config };\n    await this.saveConfig();\n    \n    if (this.config.enabled && this.config.autoSync) {\n      this.startAutoSync();\n    } else {\n      this.stopAutoSync();\n    }\n  }\n\n  private startAutoSync(): void {\n    if (this.syncInterval) {\n      clearInterval(this.syncInterval);\n    }\n    \n    this.syncInterval = setInterval(async () => {\n      try {\n        await this.sync();\n      } catch (error) {\n        console.error('[CloudSync] Auto sync error:', error);\n      }\n    }, this.config.syncInterval * 60 * 1000);\n  }\n\n  private stopAutoSync(): void {\n    if (this.syncInterval) {\n      clearInterval(this.syncInterval);\n      this.syncInterval = null;\n    }\n  }\n\n  async scanWorkspace(): Promise<void> {\n    try {\n      const workspacePath = process.cwd();\n      await this.scanDirectory(workspacePath, 'workspace');\n      \n      // Scan settings\n      await this.scanSettings();\n      \n      // Scan plugins\n      await this.scanPlugins();\n      \n      await this.saveSyncItems();\n    } catch (error) {\n      console.error('[CloudSync] Workspace scan error:', error);\n    }\n  }\n\n  private async scanDirectory(dirPath: string, type: 'workspace' | 'settings' | 'plugins'): Promise<void> {\n    try {\n      const entries = await fs.readdir(dirPath, { withFileTypes: true });\n      \n      for (const entry of entries) {\n        const fullPath = path.join(dirPath, entry.name);\n        \n        // Skip certain directories and files\n        if (this.shouldSkipPath(fullPath)) continue;\n        \n        if (entry.isDirectory()) {\n          await this.scanDirectory(fullPath, type);\n        } else if (entry.isFile()) {\n          await this.addSyncItem(fullPath, type);\n        }\n      }\n    } catch (error) {\n      console.error(`[CloudSync] Error scanning directory ${dirPath}:`, error);\n    }\n  }\n\n  private shouldSkipPath(filePath: string): boolean {\n    const skipPatterns = [\n      'node_modules',\n      '.git',\n      '.tantra',\n      'dist',\n      'build',\n      '.next',\n      '.vscode',\n      'coverage',\n      '.nyc_output',\n      '*.log',\n      '*.tmp',\n      '.DS_Store',\n    ];\n    \n    return skipPatterns.some(pattern => {\n      if (pattern.includes('*')) {\n        return filePath.includes(pattern.replace('*', ''));\n      }\n      return filePath.includes(pattern);\n    });\n  }\n\n  private async scanSettings(): Promise<void> {\n    try {\n      const settingsPath = path.join(process.cwd(), '.tantra', 'settings.json');\n      await this.addSyncItem(settingsPath, 'settings');\n    } catch (error) {\n      // Settings file doesn't exist yet\n    }\n  }\n\n  private async scanPlugins(): Promise<void> {\n    try {\n      const pluginsPath = path.join(process.cwd(), 'plugins');\n      await this.scanDirectory(pluginsPath, 'plugins');\n    } catch (error) {\n      // Plugins directory doesn't exist yet\n    }\n  }\n\n  private async addSyncItem(filePath: string, type: 'workspace' | 'settings' | 'plugins' | 'themes'): Promise<void> {\n    try {\n      const stats = await fs.stat(filePath);\n      const content = await fs.readFile(filePath, 'utf-8');\n      const hash = crypto.createHash('md5').update(content).digest('hex');\n      \n      const item: SyncItem = {\n        id: crypto.createHash('md5').update(filePath).digest('hex'),\n        type,\n        path: filePath,\n        content,\n        hash,\n        lastModified: stats.mtime,\n        synced: false,\n      };\n      \n      this.syncItems.set(item.id, item);\n    } catch (error) {\n      console.error(`[CloudSync] Error adding sync item ${filePath}:`, error);\n    }\n  }\n\n  async sync(): Promise<void> {\n    if (!this.config.enabled) return;\n    \n    try {\n      this.isOnline = true;\n      \n      // Scan for changes\n      await this.scanWorkspace();\n      \n      // Sync based on provider\n      switch (this.config.provider) {\n        case 'github':\n          await this.syncWithGitHub();\n          break;\n        case 'gitlab':\n          await this.syncWithGitLab();\n          break;\n        case 'custom':\n          await this.syncWithCustom();\n          break;\n        default:\n          await this.syncWithLocal();\n      }\n      \n      this.config.lastSync = new Date();\n      await this.saveConfig();\n      \n    } catch (error) {\n      console.error('[CloudSync] Sync error:', error);\n      this.isOnline = false;\n    }\n  }\n\n  private async syncWithGitHub(): Promise<void> {\n    if (!this.config.repository || !this.config.token) {\n      throw new Error('GitHub repository and token are required');\n    }\n    \n    // This would implement GitHub API integration\n    console.log('[CloudSync] Syncing with GitHub...');\n  }\n\n  private async syncWithGitLab(): Promise<void> {\n    if (!this.config.repository || !this.config.token) {\n      throw new Error('GitLab repository and token are required');\n    }\n    \n    // This would implement GitLab API integration\n    console.log('[CloudSync] Syncing with GitLab...');\n  }\n\n  private async syncWithCustom(): Promise<void> {\n    // This would implement custom sync provider\n    console.log('[CloudSync] Syncing with custom provider...');\n  }\n\n  private async syncWithLocal(): Promise<void> {\n    // Local sync - just save items\n    await this.saveSyncItems();\n    console.log('[CloudSync] Local sync completed');\n  }\n\n  async getSyncStatus(): Promise<SyncStatus> {\n    const pendingChanges = Array.from(this.syncItems.values()).filter(item => !item.synced).length;\n    const conflicts = 0; // This would be calculated based on conflicts\n    \n    return {\n      isOnline: this.isOnline,\n      lastSync: this.config.lastSync,\n      pendingChanges,\n      conflicts,\n      provider: this.config.provider,\n    };\n  }\n\n  async getSyncItems(): Promise<SyncItem[]> {\n    return Array.from(this.syncItems.values());\n  }\n\n  async getConfig(): Promise<SyncConfig> {\n    return { ...this.config };\n  }\n\n  async resolveConflict(itemId: string, resolution: 'local' | 'remote' | 'merge'): Promise<void> {\n    const item = this.syncItems.get(itemId);\n    if (!item) return;\n    \n    // This would implement conflict resolution\n    console.log(`[CloudSync] Resolving conflict for ${itemId} with resolution: ${resolution}`);\n  }\n\n  async forceSync(): Promise<void> {\n    await this.scanWorkspace();\n    await this.sync();\n  }\n}\n\nexport const cloudSyncService = new CloudSyncService();",
    "hash": "72e0a89af0f55f0f35f12c0dbc131c4e",
    "lastModified": "2025-10-27T08:27:34.514Z",
    "synced": false
  },
  {
    "id": "ca64af0a3fcd7c5feb078e6c9864f4bf",
    "type": "workspace",
    "path": "/workspace/backend/src/services/databaseService.ts",
    "content": "import { exec } from 'child_process';\nimport { promisify } from 'util';\nimport fs from 'fs/promises';\nimport path from 'path';\n\nconst execAsync = promisify(exec);\nconst WORKSPACE_PATH = process.env.WORKSPACE_PATH || process.cwd();\n\nexport interface DatabaseConnection {\n  id: string;\n  name: string;\n  type: 'mysql' | 'postgresql' | 'sqlite' | 'mongodb' | 'redis';\n  host?: string;\n  port?: number;\n  database?: string;\n  username?: string;\n  password?: string;\n  connectionString?: string;\n  status: 'connected' | 'disconnected' | 'error';\n}\n\nexport interface DatabaseTable {\n  name: string;\n  columns: DatabaseColumn[];\n  rowCount: number;\n  size: number;\n}\n\nexport interface DatabaseColumn {\n  name: string;\n  type: string;\n  nullable: boolean;\n  primaryKey: boolean;\n  defaultValue?: any;\n  foreignKey?: {\n    table: string;\n    column: string;\n  };\n}\n\nexport interface QueryResult {\n  columns: string[];\n  rows: any[];\n  rowCount: number;\n  executionTime: number;\n  error?: string;\n}\n\nexport interface DatabaseSchema {\n  tables: DatabaseTable[];\n  views: any[];\n  indexes: any[];\n  functions: any[];\n}\n\n// Detect database connections from project files\nexport async function detectDatabaseConnections(): Promise<DatabaseConnection[]> {\n  const connections: DatabaseConnection[] = [];\n  \n  try {\n    // Check for common database configuration files\n    const configFiles = [\n      '.env',\n      '.env.local',\n      '.env.development',\n      'config/database.js',\n      'config/database.json',\n      'prisma/schema.prisma',\n      'knexfile.js',\n      'ormconfig.js',\n    ];\n    \n    for (const configFile of configFiles) {\n      const filePath = path.join(WORKSPACE_PATH, configFile);\n      try {\n        await fs.access(filePath);\n        const content = await fs.readFile(filePath, 'utf-8');\n        const detectedConnections = parseDatabaseConfig(content, configFile);\n        connections.push(...detectedConnections);\n      } catch {\n        // File doesn't exist, continue\n      }\n    }\n    \n    // Check package.json for database dependencies\n    try {\n      const packageJsonPath = path.join(WORKSPACE_PATH, 'package.json');\n      const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf-8'));\n      const dbDependencies = detectDatabaseDependencies(packageJson);\n      connections.push(...dbDependencies);\n    } catch {\n      // No package.json or error reading it\n    }\n    \n    return connections;\n  } catch (error) {\n    console.error('Error detecting database connections:', error);\n    return [];\n  }\n}\n\nfunction parseDatabaseConfig(content: string, filename: string): DatabaseConnection[] {\n  const connections: DatabaseConnection[] = [];\n  \n  if (filename.includes('.env')) {\n    // Parse .env files\n    const lines = content.split('\\n');\n    const dbVars: Record<string, string> = {};\n    \n    for (const line of lines) {\n      const [key, value] = line.split('=');\n      if (key && value && key.toLowerCase().includes('db')) {\n        dbVars[key.trim()] = value.trim();\n      }\n    }\n    \n    if (dbVars.DATABASE_URL || dbVars.DB_URL) {\n      const url = dbVars.DATABASE_URL || dbVars.DB_URL;\n      const connection = parseConnectionString(url);\n      if (connection) {\n        connections.push({\n          id: `env-${Date.now()}`,\n          name: 'Environment Database',\n          ...connection,\n          type: connection.type || 'sqlite',\n          status: 'disconnected',\n        });\n      }\n    }\n  } else if (filename.includes('prisma')) {\n    // Parse Prisma schema\n    const urlMatch = content.match(/url\\s*=\\s*[\"']([^\"']+)[\"']/);\n    if (urlMatch) {\n      const connection = parseConnectionString(urlMatch[1]);\n      if (connection) {\n        connections.push({\n          id: `prisma-${Date.now()}`,\n          name: 'Prisma Database',\n          ...connection,\n          type: connection.type || 'sqlite',\n          status: 'disconnected',\n        });\n      }\n    }\n  }\n  \n  return connections;\n}\n\nfunction parseConnectionString(url: string): Partial<DatabaseConnection> | null {\n  try {\n    const urlObj = new URL(url);\n    const type = urlObj.protocol.replace(':', '') as DatabaseConnection['type'];\n    \n    return {\n      type,\n      host: urlObj.hostname,\n      port: parseInt(urlObj.port) || undefined,\n      database: urlObj.pathname.slice(1),\n      username: urlObj.username || undefined,\n      password: urlObj.password || undefined,\n      connectionString: url,\n    };\n  } catch {\n    return null;\n  }\n}\n\nfunction detectDatabaseDependencies(packageJson: any): DatabaseConnection[] {\n  const connections: DatabaseConnection[] = [];\n  const dependencies = { ...packageJson.dependencies, ...packageJson.devDependencies };\n  \n  const dbPackages = {\n    'mysql2': 'mysql',\n    'pg': 'postgresql',\n    'sqlite3': 'sqlite',\n    'mongodb': 'mongodb',\n    'redis': 'redis',\n    'prisma': 'postgresql', // Default for Prisma\n  };\n  \n  for (const [packageName, dbType] of Object.entries(dbPackages)) {\n    if (dependencies[packageName]) {\n      connections.push({\n        id: `package-${packageName}`,\n        name: `${packageName} Database`,\n        type: dbType as DatabaseConnection['type'],\n        status: 'disconnected',\n      });\n    }\n  }\n  \n  return connections;\n}\n\n// Test database connection\nexport async function testConnection(connection: DatabaseConnection): Promise<boolean> {\n  try {\n    switch (connection.type) {\n      case 'mysql':\n        return await testMySQLConnection(connection);\n      case 'postgresql':\n        return await testPostgreSQLConnection(connection);\n      case 'sqlite':\n        return await testSQLiteConnection(connection);\n      case 'mongodb':\n        return await testMongoDBConnection(connection);\n      case 'redis':\n        return await testRedisConnection(connection);\n      default:\n        return false;\n    }\n  } catch (error) {\n    console.error('Connection test error:', error);\n    return false;\n  }\n}\n\nasync function testMySQLConnection(connection: DatabaseConnection): Promise<boolean> {\n  try {\n    const command = `mysql -h ${connection.host} -P ${connection.port} -u ${connection.username} -p${connection.password} -e \"SELECT 1\"`;\n    await execAsync(command, { cwd: WORKSPACE_PATH });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nasync function testPostgreSQLConnection(connection: DatabaseConnection): Promise<boolean> {\n  try {\n    const command = `psql -h ${connection.host} -p ${connection.port} -U ${connection.username} -d ${connection.database} -c \"SELECT 1\"`;\n    await execAsync(command, { cwd: WORKSPACE_PATH });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nasync function testSQLiteConnection(connection: DatabaseConnection): Promise<boolean> {\n  try {\n    const dbPath = connection.database || connection.connectionString;\n    if (!dbPath) return false;\n    \n    const command = `sqlite3 \"${dbPath}\" \"SELECT 1\"`;\n    await execAsync(command, { cwd: WORKSPACE_PATH });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nasync function testMongoDBConnection(connection: DatabaseConnection): Promise<boolean> {\n  try {\n    const command = `mongosh --host ${connection.host}:${connection.port} --eval \"db.runCommand({ping: 1})\"`;\n    await execAsync(command, { cwd: WORKSPACE_PATH });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nasync function testRedisConnection(connection: DatabaseConnection): Promise<boolean> {\n  try {\n    const command = `redis-cli -h ${connection.host} -p ${connection.port} ping`;\n    const { stdout } = await execAsync(command, { cwd: WORKSPACE_PATH });\n    return stdout.trim() === 'PONG';\n  } catch {\n    return false;\n  }\n}\n\n// Execute database queries\nexport async function executeQuery(connection: DatabaseConnection, query: string): Promise<QueryResult> {\n  const startTime = Date.now();\n  \n  try {\n    switch (connection.type) {\n      case 'mysql':\n        return await executeMySQLQuery(connection, query);\n      case 'postgresql':\n        return await executePostgreSQLQuery(connection, query);\n      case 'sqlite':\n        return await executeSQLiteQuery(connection, query);\n      case 'mongodb':\n        return await executeMongoDBQuery(connection, query);\n      case 'redis':\n        return await executeRedisQuery(connection, query);\n      default:\n        throw new Error(`Unsupported database type: ${connection.type}`);\n    }\n  } catch (error: any) {\n    return {\n      columns: [],\n      rows: [],\n      rowCount: 0,\n      executionTime: Date.now() - startTime,\n      error: error.message,\n    };\n  }\n}\n\nasync function executeMySQLQuery(connection: DatabaseConnection, query: string): Promise<QueryResult> {\n  const startTime = Date.now();\n  \n  try {\n    const command = `mysql -h ${connection.host} -P ${connection.port} -u ${connection.username} -p${connection.password} -D ${connection.database} -e \"${query}\"`;\n    const { stdout } = await execAsync(command, { cwd: WORKSPACE_PATH });\n    \n    const lines = stdout.trim().split('\\n');\n    const columns = lines[0]?.split('\\t') || [];\n    const rows = lines.slice(1).map(line => line.split('\\t'));\n    \n    return {\n      columns,\n      rows,\n      rowCount: rows.length,\n      executionTime: Date.now() - startTime,\n    };\n  } catch (error: any) {\n    throw new Error(`MySQL query error: ${error.message}`);\n  }\n}\n\nasync function executePostgreSQLQuery(connection: DatabaseConnection, query: string): Promise<QueryResult> {\n  const startTime = Date.now();\n  \n  try {\n    const command = `psql -h ${connection.host} -p ${connection.port} -U ${connection.username} -d ${connection.database} -c \"${query}\"`;\n    const { stdout } = await execAsync(command, { cwd: WORKSPACE_PATH });\n    \n    // Parse PostgreSQL output (simplified)\n    const lines = stdout.trim().split('\\n');\n    const columns = lines[0]?.split('|').map(col => col.trim()) || [];\n    const rows = lines.slice(2, -2).map(line => \n      line.split('|').map(cell => cell.trim())\n    );\n    \n    return {\n      columns,\n      rows,\n      rowCount: rows.length,\n      executionTime: Date.now() - startTime,\n    };\n  } catch (error: any) {\n    throw new Error(`PostgreSQL query error: ${error.message}`);\n  }\n}\n\nasync function executeSQLiteQuery(connection: DatabaseConnection, query: string): Promise<QueryResult> {\n  const startTime = Date.now();\n  \n  try {\n    const dbPath = connection.database || connection.connectionString;\n    if (!dbPath) throw new Error('No database path provided');\n    \n    const command = `sqlite3 \"${dbPath}\" \"${query}\"`;\n    const { stdout } = await execAsync(command, { cwd: WORKSPACE_PATH });\n    \n    const lines = stdout.trim().split('\\n');\n    const rows = lines.map(line => line.split('|'));\n    \n    // For SQLite, we need to get column names separately\n    const columnQuery = `PRAGMA table_info(${extractTableName(query)})`;\n    const { stdout: columnOutput } = await execAsync(`sqlite3 \"${dbPath}\" \"${columnQuery}\"`, { cwd: WORKSPACE_PATH });\n    const columns = columnOutput.trim().split('\\n').map(line => line.split('|')[1]);\n    \n    return {\n      columns,\n      rows,\n      rowCount: rows.length,\n      executionTime: Date.now() - startTime,\n    };\n  } catch (error: any) {\n    throw new Error(`SQLite query error: ${error.message}`);\n  }\n}\n\nasync function executeMongoDBQuery(connection: DatabaseConnection, query: string): Promise<QueryResult> {\n  const startTime = Date.now();\n  \n  try {\n    // MongoDB queries are more complex, this is a simplified version\n    const command = `mongosh --host ${connection.host}:${connection.port} --eval \"${query}\"`;\n    const { stdout } = await execAsync(command, { cwd: WORKSPACE_PATH });\n    \n    return {\n      columns: ['result'],\n      rows: [[stdout.trim()]],\n      rowCount: 1,\n      executionTime: Date.now() - startTime,\n    };\n  } catch (error: any) {\n    throw new Error(`MongoDB query error: ${error.message}`);\n  }\n}\n\nasync function executeRedisQuery(connection: DatabaseConnection, query: string): Promise<QueryResult> {\n  const startTime = Date.now();\n  \n  try {\n    const command = `redis-cli -h ${connection.host} -p ${connection.port} ${query}`;\n    const { stdout } = await execAsync(command, { cwd: WORKSPACE_PATH });\n    \n    return {\n      columns: ['result'],\n      rows: [[stdout.trim()]],\n      rowCount: 1,\n      executionTime: Date.now() - startTime,\n    };\n  } catch (error: any) {\n    throw new Error(`Redis query error: ${error.message}`);\n  }\n}\n\nfunction extractTableName(query: string): string {\n  const match = query.match(/FROM\\s+(\\w+)/i);\n  return match ? match[1] : 'unknown';\n}\n\n// Get database schema\nexport async function getDatabaseSchema(connection: DatabaseConnection): Promise<DatabaseSchema> {\n  try {\n    switch (connection.type) {\n      case 'mysql':\n        return await getMySQLSchema(connection);\n      case 'postgresql':\n        return await getPostgreSQLSchema(connection);\n      case 'sqlite':\n        return await getSQLiteSchema(connection);\n      case 'mongodb':\n        return await getMongoDBSchema(connection);\n      default:\n        return { tables: [], views: [], indexes: [], functions: [] };\n    }\n  } catch (error) {\n    console.error('Schema retrieval error:', error);\n    return { tables: [], views: [], indexes: [], functions: [] };\n  }\n}\n\nasync function getMySQLSchema(connection: DatabaseConnection): Promise<DatabaseSchema> {\n  const tablesQuery = `SHOW TABLES`;\n  const result = await executeMySQLQuery(connection, tablesQuery);\n  \n  const tables: DatabaseTable[] = [];\n  \n  for (const row of result.rows) {\n    const tableName = row[0];\n    const columnsQuery = `DESCRIBE ${tableName}`;\n    const columnsResult = await executeMySQLQuery(connection, columnsQuery);\n    \n    const columns: DatabaseColumn[] = columnsResult.rows.map((col: any[]) => ({\n      name: col[0],\n      type: col[1],\n      nullable: col[2] === 'YES',\n      primaryKey: col[3] === 'PRI',\n      defaultValue: col[4],\n    }));\n    \n    tables.push({\n      name: tableName,\n      columns,\n      rowCount: 0, // Would need separate query\n      size: 0, // Would need separate query\n    });\n  }\n  \n  return { tables, views: [], indexes: [], functions: [] };\n}\n\nasync function getPostgreSQLSchema(connection: DatabaseConnection): Promise<DatabaseSchema> {\n  const tablesQuery = `SELECT table_name FROM information_schema.tables WHERE table_schema = 'public'`;\n  const result = await executePostgreSQLQuery(connection, tablesQuery);\n  \n  const tables: DatabaseTable[] = [];\n  \n  for (const row of result.rows) {\n    const tableName = row[0];\n    const columnsQuery = `\n      SELECT column_name, data_type, is_nullable, column_default\n      FROM information_schema.columns\n      WHERE table_name = '${tableName}'\n    `;\n    const columnsResult = await executePostgreSQLQuery(connection, columnsQuery);\n    \n    const columns: DatabaseColumn[] = columnsResult.rows.map((col: any[]) => ({\n      name: col[0],\n      type: col[1],\n      nullable: col[2] === 'YES',\n      primaryKey: false, // Would need separate query\n      defaultValue: col[3],\n    }));\n    \n    tables.push({\n      name: tableName,\n      columns,\n      rowCount: 0,\n      size: 0,\n    });\n  }\n  \n  return { tables, views: [], indexes: [], functions: [] };\n}\n\nasync function getSQLiteSchema(connection: DatabaseConnection): Promise<DatabaseSchema> {\n  const tablesQuery = `SELECT name FROM sqlite_master WHERE type='table'`;\n  const result = await executeSQLiteQuery(connection, tablesQuery);\n  \n  const tables: DatabaseTable[] = [];\n  \n  for (const row of result.rows) {\n    const tableName = row[0];\n    const columnsQuery = `PRAGMA table_info(${tableName})`;\n    const columnsResult = await executeSQLiteQuery(connection, columnsQuery);\n    \n    const columns: DatabaseColumn[] = columnsResult.rows.map((col: any[]) => ({\n      name: col[1],\n      type: col[2],\n      nullable: col[3] === 0,\n      primaryKey: col[5] === 1,\n      defaultValue: col[4],\n    }));\n    \n    tables.push({\n      name: tableName,\n      columns,\n      rowCount: 0,\n      size: 0,\n    });\n  }\n  \n  return { tables, views: [], indexes: [], functions: [] };\n}\n\nasync function getMongoDBSchema(connection: DatabaseConnection): Promise<DatabaseSchema> {\n  // MongoDB doesn't have a traditional schema, return collections as tables\n  const collectionsQuery = `db.runCommand(\"listCollections\")`;\n  const result = await executeMongoDBQuery(connection, collectionsQuery);\n  \n  const tables: DatabaseTable[] = [];\n  \n  // This is a simplified version - MongoDB schema analysis is more complex\n  tables.push({\n    name: 'collections',\n    columns: [\n      { name: 'name', type: 'string', nullable: false, primaryKey: true },\n      { name: 'type', type: 'string', nullable: true, primaryKey: false },\n    ],\n    rowCount: 0,\n    size: 0,\n  });\n  \n  return { tables, views: [], indexes: [], functions: [] };\n}\n\n// Query builder helpers\nexport function buildSelectQuery(table: string, columns: string[] = ['*'], where?: Record<string, any>): string {\n  let query = `SELECT ${columns.join(', ')} FROM ${table}`;\n  \n  if (where && Object.keys(where).length > 0) {\n    const conditions = Object.entries(where).map(([key, value]) => \n      `${key} = ${typeof value === 'string' ? `'${value}'` : value}`\n    );\n    query += ` WHERE ${conditions.join(' AND ')}`;\n  }\n  \n  return query;\n}\n\nexport function buildInsertQuery(table: string, data: Record<string, any>): string {\n  const columns = Object.keys(data);\n  const values = Object.values(data).map(value => \n    typeof value === 'string' ? `'${value}'` : value\n  );\n  \n  return `INSERT INTO ${table} (${columns.join(', ')}) VALUES (${values.join(', ')})`;\n}\n\nexport function buildUpdateQuery(table: string, data: Record<string, any>, where: Record<string, any>): string {\n  const sets = Object.entries(data).map(([key, value]) => \n    `${key} = ${typeof value === 'string' ? `'${value}'` : value}`\n  );\n  \n  const conditions = Object.entries(where).map(([key, value]) => \n    `${key} = ${typeof value === 'string' ? `'${value}'` : value}`\n  );\n  \n  return `UPDATE ${table} SET ${sets.join(', ')} WHERE ${conditions.join(' AND ')}`;\n}\n\nexport function buildDeleteQuery(table: string, where: Record<string, any>): string {\n  const conditions = Object.entries(where).map(([key, value]) => \n    `${key} = ${typeof value === 'string' ? `'${value}'` : value}`\n  );\n  \n  return `DELETE FROM ${table} WHERE ${conditions.join(' AND ')}`;\n}\n\n",
    "hash": "39894998763dfba814d6f8e87f1df6f4",
    "lastModified": "2025-10-27T08:49:13.755Z",
    "synced": false
  },
  {
    "id": "3ef970c8b645c0e55273ba1d35179962",
    "type": "workspace",
    "path": "/workspace/backend/src/services/debugService.ts",
    "content": "import { spawn, ChildProcess } from 'child_process';\nimport { EventEmitter } from 'events';\nimport fs from 'fs/promises';\nimport path from 'path';\n\nexport interface Breakpoint {\n  id: string;\n  file: string;\n  line: number;\n  column?: number;\n  condition?: string;\n  hitCount?: number;\n  enabled: boolean;\n}\n\nexport interface DebugSession {\n  id: string;\n  name: string;\n  type: 'node' | 'python' | 'chrome' | 'firefox' | 'custom';\n  config: DebugConfig;\n  status: 'stopped' | 'running' | 'paused' | 'terminated';\n  process?: ChildProcess;\n  breakpoints: Map<string, Breakpoint>;\n  variables: Map<string, any>;\n  callStack: CallFrame[];\n  currentFrame?: CallFrame;\n  startTime: Date;\n  endTime?: Date;\n}\n\nexport interface DebugConfig {\n  program: string;\n  args: string[];\n  cwd: string;\n  env: Record<string, string>;\n  runtimeArgs: string[];\n  console: 'integratedTerminal' | 'internalConsole' | 'externalTerminal';\n  stopOnEntry: boolean;\n  autoAttach: boolean;\n  port?: number;\n  hostname?: string;\n  timeout?: number;\n}\n\nexport interface CallFrame {\n  id: number;\n  name: string;\n  source: {\n    name: string;\n    path: string;\n    line: number;\n    column: number;\n  };\n  line: number;\n  column: number;\n  variables: Map<string, any>;\n}\n\nexport interface DebugEvent {\n  type: 'started' | 'stopped' | 'paused' | 'resumed' | 'breakpoint' | 'exception' | 'output' | 'terminated';\n  sessionId: string;\n  data?: any;\n  timestamp: Date;\n}\n\nclass DebugService extends EventEmitter {\n  private sessions: Map<string, DebugSession> = new Map();\n  private nextSessionId: number = 1;\n\n  constructor() {\n    super();\n  }\n\n  async createSession(name: string, type: string, config: DebugConfig): Promise<DebugSession> {\n    const sessionId = `debug-${this.nextSessionId++}`;\n    \n    const session: DebugSession = {\n      id: sessionId,\n      name,\n      type: type as any,\n      config,\n      status: 'stopped',\n      breakpoints: new Map(),\n      variables: new Map(),\n      callStack: [],\n      startTime: new Date(),\n    };\n\n    this.sessions.set(sessionId, session);\n    \n    this.emit('sessionCreated', { sessionId, session });\n    \n    return session;\n  }\n\n  async startSession(sessionId: string): Promise<void> {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Debug session ${sessionId} not found`);\n    }\n\n    if (session.status !== 'stopped') {\n      throw new Error(`Debug session ${sessionId} is not stopped`);\n    }\n\n    try {\n      session.status = 'running';\n      \n      // Start the debug process based on type\n      const process = await this.startDebugProcess(session);\n      session.process = process;\n      \n      // Set up process event handlers\n      this.setupProcessHandlers(session, process);\n      \n      this.emit('sessionStarted', { sessionId, session });\n      \n    } catch (error) {\n      session.status = 'stopped';\n      throw error;\n    }\n  }\n\n  async stopSession(sessionId: string): Promise<void> {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Debug session ${sessionId} not found`);\n    }\n\n    if (session.process) {\n      session.process.kill();\n      session.process = undefined;\n    }\n\n    session.status = 'terminated';\n    session.endTime = new Date();\n    \n    this.emit('sessionStopped', { sessionId, session });\n  }\n\n  async pauseSession(sessionId: string): Promise<void> {\n    const session = this.sessions.get(sessionId);\n    if (!session || !session.process) {\n      throw new Error(`Debug session ${sessionId} not found or not running`);\n    }\n\n    // Send SIGSTOP to pause the process\n    session.process.kill('SIGSTOP');\n    session.status = 'paused';\n    \n    this.emit('sessionPaused', { sessionId, session });\n  }\n\n  async resumeSession(sessionId: string): Promise<void> {\n    const session = this.sessions.get(sessionId);\n    if (!session || !session.process) {\n      throw new Error(`Debug session ${sessionId} not found or not running`);\n    }\n\n    // Send SIGCONT to resume the process\n    session.process.kill('SIGCONT');\n    session.status = 'running';\n    \n    this.emit('sessionResumed', { sessionId, session });\n  }\n\n  async addBreakpoint(sessionId: string, breakpoint: Omit<Breakpoint, 'id'>): Promise<Breakpoint> {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Debug session ${sessionId} not found`);\n    }\n\n    const bp: Breakpoint = {\n      ...breakpoint,\n      id: `bp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n    };\n\n    session.breakpoints.set(bp.id, bp);\n    \n    this.emit('breakpointAdded', { sessionId, breakpoint: bp });\n    \n    return bp;\n  }\n\n  async removeBreakpoint(sessionId: string, breakpointId: string): Promise<void> {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Debug session ${sessionId} not found`);\n    }\n\n    const removed = session.breakpoints.delete(breakpointId);\n    if (removed) {\n      this.emit('breakpointRemoved', { sessionId, breakpointId });\n    }\n  }\n\n  async updateBreakpoint(sessionId: string, breakpointId: string, updates: Partial<Breakpoint>): Promise<void> {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Debug session ${sessionId} not found`);\n    }\n\n    const breakpoint = session.breakpoints.get(breakpointId);\n    if (!breakpoint) {\n      throw new Error(`Breakpoint ${breakpointId} not found`);\n    }\n\n    Object.assign(breakpoint, updates);\n    \n    this.emit('breakpointUpdated', { sessionId, breakpoint });\n  }\n\n  async stepOver(sessionId: string): Promise<void> {\n    const session = this.sessions.get(sessionId);\n    if (!session || !session.process) {\n      throw new Error(`Debug session ${sessionId} not found or not running`);\n    }\n\n    // Send step over command to debugger\n    this.sendDebugCommand(session, 'stepOver');\n  }\n\n  async stepInto(sessionId: string): Promise<void> {\n    const session = this.sessions.get(sessionId);\n    if (!session || !session.process) {\n      throw new Error(`Debug session ${sessionId} not found or not running`);\n    }\n\n    // Send step into command to debugger\n    this.sendDebugCommand(session, 'stepInto');\n  }\n\n  async stepOut(sessionId: string): Promise<void> {\n    const session = this.sessions.get(sessionId);\n    if (!session || !session.process) {\n      throw new Error(`Debug session ${sessionId} not found or not running`);\n    }\n\n    // Send step out command to debugger\n    this.sendDebugCommand(session, 'stepOut');\n  }\n\n  async continue(sessionId: string): Promise<void> {\n    const session = this.sessions.get(sessionId);\n    if (!session || !session.process) {\n      throw new Error(`Debug session ${sessionId} not found or not running`);\n    }\n\n    // Send continue command to debugger\n    this.sendDebugCommand(session, 'continue');\n  }\n\n  async evaluateExpression(sessionId: string, expression: string): Promise<any> {\n    const session = this.sessions.get(sessionId);\n    if (!session || !session.process) {\n      throw new Error(`Debug session ${sessionId} not found or not running`);\n    }\n\n    // Send evaluate command to debugger\n    return this.sendDebugCommand(session, 'evaluate', { expression });\n  }\n\n  async getVariables(sessionId: string, frameId?: number): Promise<Map<string, any>> {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Debug session ${sessionId} not found`);\n    }\n\n    // Return variables for the specified frame or current frame\n    const frame = frameId ? session.callStack.find(f => f.id === frameId) : session.currentFrame;\n    return frame ? frame.variables : session.variables;\n  }\n\n  async getCallStack(sessionId: string): Promise<CallFrame[]> {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Debug session ${sessionId} not found`);\n    }\n\n    return session.callStack;\n  }\n\n  async setCurrentFrame(sessionId: string, frameId: number): Promise<void> {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Debug session ${sessionId} not found`);\n    }\n\n    const frame = session.callStack.find(f => f.id === frameId);\n    if (!frame) {\n      throw new Error(`Frame ${frameId} not found`);\n    }\n\n    session.currentFrame = frame;\n  }\n\n  private async startDebugProcess(session: DebugSession): Promise<ChildProcess> {\n    const { config } = session;\n    \n    switch (session.type) {\n      case 'node':\n        return this.startNodeDebugProcess(config);\n      case 'python':\n        return this.startPythonDebugProcess(config);\n      case 'chrome':\n        return this.startChromeDebugProcess(config);\n      case 'firefox':\n        return this.startFirefoxDebugProcess(config);\n      default:\n        return this.startCustomDebugProcess(config);\n    }\n  }\n\n  private async startNodeDebugProcess(config: DebugConfig): Promise<ChildProcess> {\n    const args = [\n      '--inspect',\n      ...config.runtimeArgs,\n      config.program,\n      ...config.args\n    ];\n\n    return spawn('node', args, {\n      cwd: config.cwd,\n      env: { ...process.env, ...config.env },\n      stdio: ['pipe', 'pipe', 'pipe']\n    });\n  }\n\n  private async startPythonDebugProcess(config: DebugConfig): Promise<ChildProcess> {\n    const args = [\n      '-m', 'pdb',\n      config.program,\n      ...config.args\n    ];\n\n    return spawn('python', args, {\n      cwd: config.cwd,\n      env: { ...process.env, ...config.env },\n      stdio: ['pipe', 'pipe', 'pipe']\n    });\n  }\n\n  private async startChromeDebugProcess(config: DebugConfig): Promise<ChildProcess> {\n    const args = [\n      '--remote-debugging-port=' + (config.port || 9222),\n      '--user-data-dir=/tmp/chrome-debug',\n      config.program\n    ];\n\n    return spawn('google-chrome', args, {\n      cwd: config.cwd,\n      env: { ...process.env, ...config.env },\n      stdio: ['pipe', 'pipe', 'pipe']\n    });\n  }\n\n  private async startFirefoxDebugProcess(config: DebugConfig): Promise<ChildProcess> {\n    const args = [\n      '--start-debugger-server=' + (config.port || 9222),\n      config.program\n    ];\n\n    return spawn('firefox', args, {\n      cwd: config.cwd,\n      env: { ...process.env, ...config.env },\n      stdio: ['pipe', 'pipe', 'pipe']\n    });\n  }\n\n  private async startCustomDebugProcess(config: DebugConfig): Promise<ChildProcess> {\n    return spawn(config.program, config.args, {\n      cwd: config.cwd,\n      env: { ...process.env, ...config.env },\n      stdio: ['pipe', 'pipe', 'pipe']\n    });\n  }\n\n  private setupProcessHandlers(session: DebugSession, process: ChildProcess): void {\n    process.stdout?.on('data', (data) => {\n      this.emit('debugOutput', {\n        sessionId: session.id,\n        type: 'stdout',\n        data: data.toString()\n      });\n    });\n\n    process.stderr?.on('data', (data) => {\n      this.emit('debugOutput', {\n        sessionId: session.id,\n        type: 'stderr',\n        data: data.toString()\n      });\n    });\n\n    process.on('exit', (code, signal) => {\n      session.status = 'terminated';\n      session.endTime = new Date();\n      \n      this.emit('sessionTerminated', {\n        sessionId: session.id,\n        code,\n        signal\n      });\n    });\n\n    process.on('error', (error) => {\n      this.emit('debugError', {\n        sessionId: session.id,\n        error: error.message\n      });\n    });\n  }\n\n  private async sendDebugCommand(session: DebugSession, command: string, params?: any): Promise<any> {\n    // This would send commands to the debugger process\n    // Implementation depends on the specific debugger protocol\n    console.log(`[Debug] Sending command ${command} to session ${session.id}`, params);\n    \n    // For now, just emit an event\n    this.emit('debugCommand', {\n      sessionId: session.id,\n      command,\n      params\n    });\n  }\n\n  getSession(sessionId: string): DebugSession | undefined {\n    return this.sessions.get(sessionId);\n  }\n\n  getAllSessions(): DebugSession[] {\n    return Array.from(this.sessions.values());\n  }\n\n  async cleanup(): Promise<void> {\n    // Stop all active sessions\n    for (const session of this.sessions.values()) {\n      if (session.status === 'running' || session.status === 'paused') {\n        await this.stopSession(session.id);\n      }\n    }\n  }\n}\n\nexport const debugService = new DebugService();",
    "hash": "3e9d183907b3374a5f5f6f40da4ef9a5",
    "lastModified": "2025-10-27T08:27:34.502Z",
    "synced": false
  },
  {
    "id": "769f9df8e80fa2ea720c5908c2d30a3e",
    "type": "workspace",
    "path": "/workspace/backend/src/services/deploymentService.ts",
    "content": "import { exec } from 'child_process';\nimport { promisify } from 'util';\nimport axios from 'axios';\nimport fs from 'fs/promises';\nimport path from 'path';\n\nconst execAsync = promisify(exec);\nconst WORKSPACE_PATH = process.env.WORKSPACE_PATH || process.cwd();\n\nexport interface DeploymentConfig {\n  platform: 'vercel' | 'netlify' | 'aws' | 'github-pages';\n  projectName: string;\n  buildCommand?: string;\n  outputDirectory?: string;\n  environmentVariables?: Record<string, string>;\n  customDomain?: string;\n}\n\nexport interface DeploymentStatus {\n  id: string;\n  status: 'pending' | 'building' | 'deployed' | 'failed';\n  url?: string;\n  logs?: string[];\n  createdAt: Date;\n  completedAt?: Date;\n}\n\nexport interface PlatformInfo {\n  name: string;\n  supported: boolean;\n  installed: boolean;\n  version?: string;\n}\n\n// Vercel Deployment\nexport async function deployToVercel(config: DeploymentConfig): Promise<DeploymentStatus> {\n  try {\n    // Check if Vercel CLI is installed\n    try {\n      await execAsync('vercel --version', { cwd: WORKSPACE_PATH });\n    } catch {\n      // Install Vercel CLI\n      await execAsync('npm install -g vercel', { cwd: WORKSPACE_PATH });\n    }\n\n    // Create vercel.json if it doesn't exist\n    const vercelConfigPath = path.join(WORKSPACE_PATH, 'vercel.json');\n    try {\n      await fs.access(vercelConfigPath);\n    } catch {\n      const vercelConfig = {\n        version: 2,\n        builds: [\n          {\n            src: config.outputDirectory ? `${config.outputDirectory}/**/*` : '**/*',\n            use: '@vercel/static',\n          },\n        ],\n        routes: [\n          {\n            src: '/(.*)',\n            dest: config.outputDirectory ? `/${config.outputDirectory}/$1` : '/$1',\n          },\n        ],\n      };\n      await fs.writeFile(vercelConfigPath, JSON.stringify(vercelConfig, null, 2));\n    }\n\n    // Set environment variables\n    if (config.environmentVariables) {\n      for (const [key, value] of Object.entries(config.environmentVariables)) {\n        await execAsync(`vercel env add ${key} ${value}`, { cwd: WORKSPACE_PATH });\n      }\n    }\n\n    // Deploy\n    const { stdout } = await execAsync('vercel --prod --yes', { cwd: WORKSPACE_PATH });\n    \n    // Extract URL from output\n    const urlMatch = stdout.match(/https:\\/\\/[^\\s]+/);\n    const url = urlMatch ? urlMatch[0] : undefined;\n\n    return {\n      id: `vercel-${Date.now()}`,\n      status: 'deployed',\n      url,\n      logs: [stdout],\n      createdAt: new Date(),\n      completedAt: new Date(),\n    };\n  } catch (error: any) {\n    return {\n      id: `vercel-${Date.now()}`,\n      status: 'failed',\n      logs: [error.message],\n      createdAt: new Date(),\n    };\n  }\n}\n\n// Netlify Deployment\nexport async function deployToNetlify(config: DeploymentConfig): Promise<DeploymentStatus> {\n  try {\n    // Check if Netlify CLI is installed\n    try {\n      await execAsync('netlify --version', { cwd: WORKSPACE_PATH });\n    } catch {\n      // Install Netlify CLI\n      await execAsync('npm install -g netlify-cli', { cwd: WORKSPACE_PATH });\n    }\n\n    // Create netlify.toml if it doesn't exist\n    const netlifyConfigPath = path.join(WORKSPACE_PATH, 'netlify.toml');\n    try {\n      await fs.access(netlifyConfigPath);\n    } catch {\n      const netlifyConfig = `\n[build]\n  publish = \"${config.outputDirectory || 'dist'}\"\n  command = \"${config.buildCommand || 'npm run build'}\"\n\n[build.environment]\n${Object.entries(config.environmentVariables || {}).map(([key, value]) => `  ${key} = \"${value}\"`).join('\\n')}\n\n[[redirects]]\n  from = \"/*\"\n  to = \"/index.html\"\n  status = 200\n`;\n      await fs.writeFile(netlifyConfigPath, netlifyConfig);\n    }\n\n    // Deploy\n    const { stdout } = await execAsync('netlify deploy --prod', { cwd: WORKSPACE_PATH });\n    \n    // Extract URL from output\n    const urlMatch = stdout.match(/https:\\/\\/[^\\s]+/);\n    const url = urlMatch ? urlMatch[0] : undefined;\n\n    return {\n      id: `netlify-${Date.now()}`,\n      status: 'deployed',\n      url,\n      logs: [stdout],\n      createdAt: new Date(),\n      completedAt: new Date(),\n    };\n  } catch (error: any) {\n    return {\n      id: `netlify-${Date.now()}`,\n      status: 'failed',\n      logs: [error.message],\n      createdAt: new Date(),\n    };\n  }\n}\n\n// AWS S3 + CloudFront Deployment\nexport async function deployToAWS(config: DeploymentConfig): Promise<DeploymentStatus> {\n  try {\n    // Check if AWS CLI is installed\n    try {\n      await execAsync('aws --version', { cwd: WORKSPACE_PATH });\n    } catch {\n      throw new Error('AWS CLI not installed. Please install AWS CLI first.');\n    }\n\n    const bucketName = `${config.projectName}-${Date.now()}`;\n    const region = 'us-east-1';\n\n    // Create S3 bucket\n    await execAsync(`aws s3 mb s3://${bucketName} --region ${region}`, { cwd: WORKSPACE_PATH });\n\n    // Upload files\n    const sourceDir = config.outputDirectory || 'dist';\n    await execAsync(`aws s3 sync ${sourceDir} s3://${bucketName} --delete`, { cwd: WORKSPACE_PATH });\n\n    // Configure bucket for static website hosting\n    await execAsync(`aws s3 website s3://${bucketName} --index-document index.html --error-document error.html`, { cwd: WORKSPACE_PATH });\n\n    // Set bucket policy for public read\n    const bucketPolicy = {\n      Version: '2012-10-17',\n      Statement: [\n        {\n          Sid: 'PublicReadGetObject',\n          Effect: 'Allow',\n          Principal: '*',\n          Action: 's3:GetObject',\n          Resource: `arn:aws:s3:::${bucketName}/*`,\n        },\n      ],\n    };\n\n    await fs.writeFile('bucket-policy.json', JSON.stringify(bucketPolicy));\n    await execAsync(`aws s3api put-bucket-policy --bucket ${bucketName} --policy file://bucket-policy.json`, { cwd: WORKSPACE_PATH });\n    await fs.unlink('bucket-policy.json');\n\n    const url = `http://${bucketName}.s3-website-${region}.amazonaws.com`;\n\n    return {\n      id: `aws-${Date.now()}`,\n      status: 'deployed',\n      url,\n      logs: [`Deployed to S3 bucket: ${bucketName}`],\n      createdAt: new Date(),\n      completedAt: new Date(),\n    };\n  } catch (error: any) {\n    return {\n      id: `aws-${Date.now()}`,\n      status: 'failed',\n      logs: [error.message],\n      createdAt: new Date(),\n    };\n  }\n}\n\n// GitHub Pages Deployment\nexport async function deployToGitHubPages(config: DeploymentConfig): Promise<DeploymentStatus> {\n  try {\n    // Check if we're in a git repository\n    try {\n      await execAsync('git status', { cwd: WORKSPACE_PATH });\n    } catch {\n      throw new Error('Not a git repository. Please initialize git first.');\n    }\n\n    // Create gh-pages branch if it doesn't exist\n    try {\n      await execAsync('git checkout gh-pages', { cwd: WORKSPACE_PATH });\n    } catch {\n      await execAsync('git checkout -b gh-pages', { cwd: WORKSPACE_PATH });\n    }\n\n    // Build the project\n    if (config.buildCommand) {\n      await execAsync(config.buildCommand, { cwd: WORKSPACE_PATH });\n    }\n\n    // Copy build output to root\n    const sourceDir = config.outputDirectory || 'dist';\n    await execAsync(`cp -r ${sourceDir}/* .`, { cwd: WORKSPACE_PATH });\n\n    // Commit and push\n    await execAsync('git add .', { cwd: WORKSPACE_PATH });\n    await execAsync('git commit -m \"Deploy to GitHub Pages\"', { cwd: WORKSPACE_PATH });\n    await execAsync('git push origin gh-pages', { cwd: WORKSPACE_PATH });\n\n    // Switch back to main branch\n    await execAsync('git checkout main', { cwd: WORKSPACE_PATH });\n\n    const url = `https://${config.projectName}.github.io`;\n\n    return {\n      id: `github-pages-${Date.now()}`,\n      status: 'deployed',\n      url,\n      logs: ['Deployed to GitHub Pages'],\n      createdAt: new Date(),\n      completedAt: new Date(),\n    };\n  } catch (error: any) {\n    return {\n      id: `github-pages-${Date.now()}`,\n      status: 'failed',\n      logs: [error.message],\n      createdAt: new Date(),\n    };\n  }\n}\n\n// Main deployment function\nexport async function deployProject(config: DeploymentConfig): Promise<DeploymentStatus> {\n  switch (config.platform) {\n    case 'vercel':\n      return await deployToVercel(config);\n    case 'netlify':\n      return await deployToNetlify(config);\n    case 'aws':\n      return await deployToAWS(config);\n    case 'github-pages':\n      return await deployToGitHubPages(config);\n    default:\n      throw new Error(`Unsupported platform: ${config.platform}`);\n  }\n}\n\n// Check platform availability\nexport async function checkPlatformAvailability(): Promise<PlatformInfo[]> {\n  const platforms: PlatformInfo[] = [\n    { name: 'vercel', supported: true, installed: false },\n    { name: 'netlify', supported: true, installed: false },\n    { name: 'aws', supported: true, installed: false },\n    { name: 'github-pages', supported: true, installed: false },\n  ];\n\n  for (const platform of platforms) {\n    try {\n      switch (platform.name) {\n        case 'vercel':\n          const vercelVersion = await execAsync('vercel --version', { cwd: WORKSPACE_PATH });\n          platform.installed = true;\n          platform.version = vercelVersion.stdout.trim();\n          break;\n        case 'netlify':\n          const netlifyVersion = await execAsync('netlify --version', { cwd: WORKSPACE_PATH });\n          platform.installed = true;\n          platform.version = netlifyVersion.stdout.trim();\n          break;\n        case 'aws':\n          const awsVersion = await execAsync('aws --version', { cwd: WORKSPACE_PATH });\n          platform.installed = true;\n          platform.version = awsVersion.stdout.trim();\n          break;\n        case 'github-pages':\n          // GitHub Pages doesn't need CLI, just git\n          try {\n            await execAsync('git --version', { cwd: WORKSPACE_PATH });\n            platform.installed = true;\n          } catch {\n            platform.installed = false;\n          }\n          break;\n      }\n    } catch {\n      platform.installed = false;\n    }\n  }\n\n  return platforms;\n}\n\n// Auto-detect deployment configuration\nexport async function detectDeploymentConfig(): Promise<DeploymentConfig | null> {\n  try {\n    // Check for package.json\n    const packageJsonPath = path.join(WORKSPACE_PATH, 'package.json');\n    const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf-8'));\n\n    // Detect framework\n    let platform: DeploymentConfig['platform'] = 'vercel';\n    let buildCommand = 'npm run build';\n    let outputDirectory = 'dist';\n\n    if (packageJson.dependencies?.next) {\n      platform = 'vercel';\n      outputDirectory = '.next';\n    } else if (packageJson.dependencies?.react) {\n      platform = 'netlify';\n      outputDirectory = 'build';\n    } else if (packageJson.dependencies?.vue) {\n      platform = 'netlify';\n      outputDirectory = 'dist';\n    } else if (packageJson.dependencies?.nuxt) {\n      platform = 'vercel';\n      outputDirectory = '.nuxt';\n    }\n\n    return {\n      platform,\n      projectName: packageJson.name || 'my-project',\n      buildCommand,\n      outputDirectory,\n      environmentVariables: {},\n    };\n  } catch {\n    return null;\n  }\n}\n\n// Get deployment history\nexport async function getDeploymentHistory(): Promise<DeploymentStatus[]> {\n  // In a real implementation, this would read from a database\n  // For now, return empty array\n  return [];\n}\n\n",
    "hash": "1e47a06901877c6354ebfc56aef99605",
    "lastModified": "2025-10-27T08:27:34.506Z",
    "synced": false
  },
  {
    "id": "35a954b1db607bc7a295fcff27cdc8f1",
    "type": "workspace",
    "path": "/workspace/backend/src/services/fileService.ts",
    "content": "import fs from 'fs/promises';\nimport path from 'path';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\n\nconst execAsync = promisify(exec);\n\n// Configuration\nconst WORKSPACE_PATH = process.env.WORKSPACE_PATH || process.cwd();\nconst MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB limit\nconst ALLOWED_EXTENSIONS = new Set([\n  '.js', '.ts', '.jsx', '.tsx', '.json', '.md', '.txt', '.css', '.scss', '.html', '.xml',\n  '.py', '.java', '.cpp', '.c', '.h', '.hpp', '.cs', '.php', '.rb', '.go', '.rs', '.swift',\n  '.kt', '.scala', '.sh', '.bash', '.zsh', '.fish', '.ps1', '.bat', '.yml', '.yaml',\n  '.toml', '.ini', '.cfg', '.conf', '.env', '.gitignore', '.dockerfile', '.sql'\n]);\n\n// Type definitions\ninterface FileNode {\n  name: string;\n  path: string;\n  type: 'file' | 'directory';\n  children?: FileNode[];\n  size?: number;\n  modified?: number;\n  extension?: string;\n}\n\ninterface SearchResult {\n  path: string;\n  line: number;\n  content: string;\n  match: string;\n}\n\n// Utility functions\nfunction isValidPath(inputPath: string): boolean {\n  // Prevent directory traversal attacks\n  const normalizedPath = path.normalize(inputPath);\n  return !normalizedPath.includes('..') && !normalizedPath.startsWith('/');\n}\n\nfunction getFileExtension(filename: string): string {\n  return path.extname(filename).toLowerCase();\n}\n\nfunction isAllowedFile(filename: string): boolean {\n  const ext = getFileExtension(filename);\n  return ALLOWED_EXTENSIONS.has(ext) || ext === '';\n}\n\n// Main service functions\nexport async function getFileTree(relativePath: string): Promise<FileNode[]> {\n  if (!isValidPath(relativePath)) {\n    throw new Error('Invalid path: potential directory traversal detected');\n  }\n\n  const fullPath = path.join(WORKSPACE_PATH, relativePath);\n  \n  try {\n    const stats = await fs.stat(fullPath);\n    if (!stats.isDirectory()) {\n      throw new Error('Path is not a directory');\n    }\n\n    const entries = await fs.readdir(fullPath, { withFileTypes: true });\n    const nodes: FileNode[] = [];\n    \n    // Process entries in parallel for better performance\n    const nodePromises = entries.map(async (entry) => {\n      // Skip hidden files, node_modules, and build directories\n      if (entry.name.startsWith('.') || \n          entry.name === 'node_modules' || \n          entry.name === 'dist' || \n          entry.name === 'build' ||\n          entry.name === '.git') {\n        return null;\n      }\n      \n      const entryPath = path.join(relativePath, entry.name);\n      const fullEntryPath = path.join(fullPath, entry.name);\n      \n      try {\n        const stats = await fs.stat(fullEntryPath);\n        \n        const node: FileNode = {\n          name: entry.name,\n          path: entryPath,\n          type: entry.isDirectory() ? 'directory' : 'file',\n          size: stats.size,\n          modified: stats.mtimeMs,\n          extension: entry.isFile() ? getFileExtension(entry.name) : undefined,\n        };\n        \n        // Recursively get children for directories (with depth limit)\n        if (entry.isDirectory() && entryPath.split('/').length < 10) {\n          try {\n            node.children = await getFileTree(entryPath);\n          } catch (error) {\n            console.warn(`Error reading subdirectory ${entryPath}:`, error);\n            node.children = [];\n          }\n        }\n        \n        return node;\n      } catch (error) {\n        console.warn(`Error processing ${entryPath}:`, error);\n        return null;\n      }\n    });\n    \n    const resolvedNodes = await Promise.all(nodePromises);\n    const validNodes = resolvedNodes.filter((node): node is FileNode => node !== null);\n    \n    // Sort: directories first, then files, both alphabetically\n    return validNodes.sort((a, b) => {\n      if (a.type !== b.type) {\n        return a.type === 'directory' ? -1 : 1;\n      }\n      return a.name.localeCompare(b.name);\n    });\n  } catch (error) {\n    console.error(`Error reading directory ${fullPath}:`, error);\n    throw new Error(`Failed to read directory: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n\nexport async function readFile(relativePath: string): Promise<string> {\n  if (!isValidPath(relativePath)) {\n    throw new Error('Invalid path: potential directory traversal detected');\n  }\n\n  const fullPath = path.join(WORKSPACE_PATH, relativePath);\n  \n  try {\n    const stats = await fs.stat(fullPath);\n    \n    if (!stats.isFile()) {\n      throw new Error('Path is not a file');\n    }\n    \n    if (stats.size > MAX_FILE_SIZE) {\n      throw new Error(`File too large: ${stats.size} bytes (max: ${MAX_FILE_SIZE})`);\n    }\n    \n    if (!isAllowedFile(relativePath)) {\n      throw new Error('File type not allowed');\n    }\n    \n    return await fs.readFile(fullPath, 'utf-8');\n  } catch (error) {\n    console.error(`Error reading file ${fullPath}:`, error);\n    throw new Error(`Failed to read file: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n\nexport async function writeFile(relativePath: string, content: string): Promise<void> {\n  if (!isValidPath(relativePath)) {\n    throw new Error('Invalid path: potential directory traversal detected');\n  }\n\n  const fullPath = path.join(WORKSPACE_PATH, relativePath);\n  \n  try {\n    // Validate file size\n    if (content.length > MAX_FILE_SIZE) {\n      throw new Error(`Content too large: ${content.length} bytes (max: ${MAX_FILE_SIZE})`);\n    }\n    \n    if (!isAllowedFile(relativePath)) {\n      throw new Error('File type not allowed');\n    }\n    \n    // Ensure directory exists\n    await fs.mkdir(path.dirname(fullPath), { recursive: true });\n    \n    await fs.writeFile(fullPath, content, 'utf-8');\n  } catch (error) {\n    console.error(`Error writing file ${fullPath}:`, error);\n    throw new Error(`Failed to write file: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n\nexport async function createFile(relativePath: string, content: string = ''): Promise<void> {\n  await writeFile(relativePath, content);\n}\n\nexport async function deleteFile(relativePath: string): Promise<void> {\n  if (!isValidPath(relativePath)) {\n    throw new Error('Invalid path: potential directory traversal detected');\n  }\n\n  const fullPath = path.join(WORKSPACE_PATH, relativePath);\n  \n  try {\n    const stats = await fs.stat(fullPath);\n    \n    if (stats.isDirectory()) {\n      await fs.rm(fullPath, { recursive: true, force: true });\n    } else {\n      await fs.unlink(fullPath);\n    }\n  } catch (error) {\n    console.error(`Error deleting ${fullPath}:`, error);\n    throw new Error(`Failed to delete: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n\nexport async function renameFile(oldRelativePath: string, newRelativePath: string): Promise<void> {\n  if (!isValidPath(oldRelativePath) || !isValidPath(newRelativePath)) {\n    throw new Error('Invalid path: potential directory traversal detected');\n  }\n\n  const oldFullPath = path.join(WORKSPACE_PATH, oldRelativePath);\n  const newFullPath = path.join(WORKSPACE_PATH, newRelativePath);\n  \n  try {\n    // Check if source exists\n    await fs.access(oldFullPath);\n    \n    // Ensure destination directory exists\n    await fs.mkdir(path.dirname(newFullPath), { recursive: true });\n    \n    await fs.rename(oldFullPath, newFullPath);\n  } catch (error) {\n    console.error(`Error renaming ${oldFullPath} to ${newFullPath}:`, error);\n    throw new Error(`Failed to rename: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n\nexport async function createFolder(relativePath: string): Promise<void> {\n  if (!isValidPath(relativePath)) {\n    throw new Error('Invalid path: potential directory traversal detected');\n  }\n\n  const fullPath = path.join(WORKSPACE_PATH, relativePath);\n  \n  try {\n    await fs.mkdir(fullPath, { recursive: true });\n  } catch (error) {\n    console.error(`Error creating folder ${fullPath}:`, error);\n    throw new Error(`Failed to create folder: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n\nexport async function searchFiles(pattern: string, relativePath: string = '.'): Promise<SearchResult[]> {\n  if (!isValidPath(relativePath)) {\n    throw new Error('Invalid path: potential directory traversal detected');\n  }\n\n  const fullPath = path.join(WORKSPACE_PATH, relativePath);\n  \n  try {\n    // Validate search pattern\n    if (!pattern || pattern.length < 2) {\n      throw new Error('Search pattern must be at least 2 characters');\n    }\n    \n    // Escape special characters for shell safety\n    const escapedPattern = pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    \n    // Try using ripgrep first (faster and more accurate)\n    try {\n      const { stdout } = await execAsync(\n        `rg \"${escapedPattern}\" --json --max-count 1000 \"${fullPath}\"`,\n        { maxBuffer: 10 * 1024 * 1024, timeout: 30000 }\n      );\n      \n      const results: SearchResult[] = stdout\n        .split('\\n')\n        .filter(line => line.trim())\n        .map(line => {\n          try {\n            const parsed = JSON.parse(line);\n            if (parsed.type === 'match') {\n              return {\n                path: parsed.data.path.text,\n                line: parsed.data.line_number,\n                content: parsed.data.lines.text.trim(),\n                match: parsed.data.submatches[0]?.match.text || '',\n              };\n            }\n            return null;\n          } catch {\n            return null;\n          }\n        })\n        .filter((result): result is SearchResult => result !== null);\n      \n      return results;\n    } catch (ripgrepError) {\n      console.warn('Ripgrep not available, falling back to grep:', ripgrepError);\n      \n      // Fallback to grep\n      const { stdout } = await execAsync(\n        `grep -rn --max-count 1000 \"${escapedPattern}\" \"${fullPath}\"`,\n        { maxBuffer: 10 * 1024 * 1024, timeout: 30000 }\n      );\n      \n      return stdout.split('\\n')\n        .filter(line => line.trim())\n        .map(line => {\n          const match = line.match(/^([^:]+):(\\d+):(.+)$/);\n          if (match) {\n            return {\n              path: match[1],\n              line: parseInt(match[2], 10),\n              content: match[3].trim(),\n              match: pattern,\n            };\n          }\n          return null;\n        })\n        .filter((result): result is SearchResult => result !== null);\n    }\n  } catch (error) {\n    console.error(`Error searching in ${fullPath}:`, error);\n    throw new Error(`Search failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n\n// Additional utility functions\nexport async function getFileStats(relativePath: string): Promise<{\n  size: number;\n  modified: number;\n  created: number;\n  isFile: boolean;\n  isDirectory: boolean;\n}> {\n  if (!isValidPath(relativePath)) {\n    throw new Error('Invalid path: potential directory traversal detected');\n  }\n\n  const fullPath = path.join(WORKSPACE_PATH, relativePath);\n  \n  try {\n    const stats = await fs.stat(fullPath);\n    return {\n      size: stats.size,\n      modified: stats.mtimeMs,\n      created: stats.birthtimeMs,\n      isFile: stats.isFile(),\n      isDirectory: stats.isDirectory(),\n    };\n  } catch (error) {\n    console.error(`Error getting stats for ${fullPath}:`, error);\n    throw new Error(`Failed to get file stats: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n\nexport async function copyFile(sourcePath: string, destPath: string): Promise<void> {\n  if (!isValidPath(sourcePath) || !isValidPath(destPath)) {\n    throw new Error('Invalid path: potential directory traversal detected');\n  }\n\n  const sourceFullPath = path.join(WORKSPACE_PATH, sourcePath);\n  const destFullPath = path.join(WORKSPACE_PATH, destPath);\n  \n  try {\n    await fs.mkdir(path.dirname(destFullPath), { recursive: true });\n    await fs.copyFile(sourceFullPath, destFullPath);\n  } catch (error) {\n    console.error(`Error copying ${sourcePath} to ${destPath}:`, error);\n    throw new Error(`Failed to copy file: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n\n",
    "hash": "76de89b5baefde5d7aea9b800c0f077d",
    "lastModified": "2025-10-27T08:27:34.506Z",
    "synced": false
  },
  {
    "id": "d63c18267120a6ca838993b81c38e9b3",
    "type": "workspace",
    "path": "/workspace/backend/src/services/gitService.ts",
    "content": "import { exec } from 'child_process';\nimport { promisify } from 'util';\nimport path from 'path';\n\nconst execAsync = promisify(exec);\n\nconst WORKSPACE_PATH = process.env.WORKSPACE_PATH || process.cwd();\n\nexport interface GitChange {\n  path: string;\n  status: 'modified' | 'added' | 'deleted' | 'untracked' | 'conflict' | null;\n  diff?: string;\n}\n\nexport interface GitCommit {\n  hash: string;\n  message: string;\n  author: string;\n  date: string;\n}\n\nexport async function getGitStatus(): Promise<GitChange[]> {\n  try {\n    const { stdout } = await execAsync('git status --porcelain', {\n      cwd: WORKSPACE_PATH,\n    });\n    \n    const changes: GitChange[] = [];\n    const lines = stdout.trim().split('\\n').filter(line => line.trim());\n    \n    for (const line of lines) {\n      const status = line.substring(0, 2);\n      const filePath = line.substring(3);\n      \n      let changeStatus: GitChange['status'] = null;\n      \n      if (status.includes('M')) changeStatus = 'modified';\n      else if (status.includes('A')) changeStatus = 'added';\n      else if (status.includes('D')) changeStatus = 'deleted';\n      else if (status.includes('U')) changeStatus = 'conflict';\n      else if (status.includes('?')) changeStatus = 'untracked';\n      \n      changes.push({\n        path: filePath,\n        status: changeStatus,\n      });\n    }\n    \n    return changes;\n  } catch (error) {\n    console.error('Git status error:', error);\n    return [];\n  }\n}\n\nexport async function getGitDiff(filePath?: string): Promise<string> {\n  try {\n    const command = filePath ? `git diff ${filePath}` : 'git diff';\n    const { stdout } = await execAsync(command, {\n      cwd: WORKSPACE_PATH,\n    });\n    return stdout;\n  } catch (error) {\n    console.error('Git diff error:', error);\n    return '';\n  }\n}\n\nexport async function commitChanges(message: string, files?: string[]): Promise<void> {\n  try {\n    if (files && files.length > 0) {\n      // Add specific files\n      for (const file of files) {\n        await execAsync(`git add \"${file}\"`, { cwd: WORKSPACE_PATH });\n      }\n    } else {\n      // Add all changes\n      await execAsync('git add .', { cwd: WORKSPACE_PATH });\n    }\n    \n    // Commit\n    await execAsync(`git commit -m \"${message}\"`, { cwd: WORKSPACE_PATH });\n  } catch (error) {\n    console.error('Git commit error:', error);\n    throw error;\n  }\n}\n\nexport async function pushChanges(remote: string = 'origin', branch: string = 'main'): Promise<void> {\n  try {\n    await execAsync(`git push ${remote} ${branch}`, { cwd: WORKSPACE_PATH });\n  } catch (error) {\n    console.error('Git push error:', error);\n    throw error;\n  }\n}\n\nexport async function pullChanges(remote: string = 'origin', branch: string = 'main'): Promise<void> {\n  try {\n    await execAsync(`git pull ${remote} ${branch}`, { cwd: WORKSPACE_PATH });\n  } catch (error) {\n    console.error('Git pull error:', error);\n    throw error;\n  }\n}\n\nexport async function getCurrentBranch(): Promise<string> {\n  try {\n    const { stdout } = await execAsync('git branch --show-current', {\n      cwd: WORKSPACE_PATH,\n    });\n    return stdout.trim();\n  } catch (error) {\n    console.error('Git branch error:', error);\n    return 'main';\n  }\n}\n\nexport async function getGitHistory(limit: number = 10): Promise<GitCommit[]> {\n  try {\n    const { stdout } = await execAsync(\n      `git log --oneline --format=\"%H|%s|%an|%ad\" --date=short -${limit}`,\n      { cwd: WORKSPACE_PATH }\n    );\n    \n    const commits: GitCommit[] = [];\n    const lines = stdout.trim().split('\\n').filter(line => line.trim());\n    \n    for (const line of lines) {\n      const [hash, message, author, date] = line.split('|');\n      commits.push({\n        hash,\n        message,\n        author,\n        date,\n      });\n    }\n    \n    return commits;\n  } catch (error) {\n    console.error('Git history error:', error);\n    return [];\n  }\n}\n\nexport async function createBranch(branchName: string): Promise<void> {\n  try {\n    await execAsync(`git checkout -b ${branchName}`, { cwd: WORKSPACE_PATH });\n  } catch (error) {\n    console.error('Git create branch error:', error);\n    throw error;\n  }\n}\n\nexport async function switchBranch(branchName: string): Promise<void> {\n  try {\n    await execAsync(`git checkout ${branchName}`, { cwd: WORKSPACE_PATH });\n  } catch (error) {\n    console.error('Git switch branch error:', error);\n    throw error;\n  }\n}\n\nexport async function getBranches(): Promise<string[]> {\n  try {\n    const { stdout } = await execAsync('git branch -a', { cwd: WORKSPACE_PATH });\n    return stdout\n      .split('\\n')\n      .map(line => line.trim().replace(/^\\*?\\s*/, '').replace(/^remotes\\/[^\\/]+\\//, ''))\n      .filter(line => line && !line.includes('HEAD'))\n      .filter((value, index, self) => self.indexOf(value) === index);\n  } catch (error) {\n    console.error('Git branches error:', error);\n    return [];\n  }\n}\n\nexport async function isGitRepository(): Promise<boolean> {\n  try {\n    await execAsync('git rev-parse --git-dir', { cwd: WORKSPACE_PATH });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n",
    "hash": "1e7b8ed9096d0bd10662d8331eddc41e",
    "lastModified": "2025-10-27T08:27:34.506Z",
    "synced": false
  },
  {
    "id": "f16187c6678def0e0a60fb24cacd625b",
    "type": "workspace",
    "path": "/workspace/backend/src/services/mediaService.ts",
    "content": "import fs from 'fs/promises';\nimport path from 'path';\nimport axios from 'axios';\nimport sharp from 'sharp';\n\nconst WORKSPACE_PATH = process.env.WORKSPACE_PATH || process.cwd();\nconst OLLAMA_URL = process.env.OLLAMA_URL || 'http://localhost:11434';\n\nexport interface MediaFile {\n  id: string;\n  path: string;\n  type: 'image' | 'video' | 'audio';\n  size: number;\n  width?: number;\n  height?: number;\n  thumbnail?: string;\n  tags?: string[];\n  usedIn?: string[];\n  optimized: boolean;\n}\n\nexport interface MediaStats {\n  totalFiles: number;\n  totalSize: number;\n  byType: {\n    image: number;\n    video: number;\n    audio: number;\n  };\n  unusedFiles: number;\n}\n\nconst SUPPORTED_IMAGE_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.svg'];\nconst SUPPORTED_VIDEO_EXTENSIONS = ['.mp4', '.avi', '.mov', '.wmv', '.flv', '.webm', '.mkv'];\nconst SUPPORTED_AUDIO_EXTENSIONS = ['.mp3', '.wav', '.flac', '.aac', '.ogg', '.m4a'];\n\nexport async function getAllMediaFiles(): Promise<MediaFile[]> {\n  const mediaFiles: MediaFile[] = [];\n  \n  try {\n    await scanDirectory(WORKSPACE_PATH, mediaFiles);\n    return mediaFiles;\n  } catch (error) {\n    console.error('Error scanning media files:', error);\n    return [];\n  }\n}\n\nasync function scanDirectory(dirPath: string, mediaFiles: MediaFile[]): Promise<void> {\n  try {\n    const entries = await fs.readdir(dirPath, { withFileTypes: true });\n    \n    for (const entry of entries) {\n      const fullPath = path.join(dirPath, entry.name);\n      \n      // Skip hidden files and node_modules\n      if (entry.name.startsWith('.') || entry.name === 'node_modules') {\n        continue;\n      }\n      \n      if (entry.isDirectory()) {\n        await scanDirectory(fullPath, mediaFiles);\n      } else if (entry.isFile()) {\n        const ext = path.extname(entry.name).toLowerCase();\n        \n        if (isMediaFile(ext)) {\n          const stats = await fs.stat(fullPath);\n          const relativePath = path.relative(WORKSPACE_PATH, fullPath);\n          \n          const mediaFile: MediaFile = {\n            id: `media-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n            path: relativePath,\n            type: getMediaType(ext),\n            size: stats.size,\n            optimized: false,\n          };\n          \n          // Get dimensions for images\n          if (mediaFile.type === 'image') {\n            try {\n              const metadata = await sharp(fullPath).metadata();\n              mediaFile.width = metadata.width;\n              mediaFile.height = metadata.height;\n              \n              // Generate thumbnail\n              mediaFile.thumbnail = await generateThumbnail(fullPath);\n            } catch (error) {\n              console.error(`Error processing image ${fullPath}:`, error);\n            }\n          }\n          \n          mediaFiles.push(mediaFile);\n        }\n      }\n    }\n  } catch (error) {\n    console.error(`Error scanning directory ${dirPath}:`, error);\n  }\n}\n\nfunction isMediaFile(extension: string): boolean {\n  return [\n    ...SUPPORTED_IMAGE_EXTENSIONS,\n    ...SUPPORTED_VIDEO_EXTENSIONS,\n    ...SUPPORTED_AUDIO_EXTENSIONS,\n  ].includes(extension);\n}\n\nfunction getMediaType(extension: string): 'image' | 'video' | 'audio' {\n  if (SUPPORTED_IMAGE_EXTENSIONS.includes(extension)) return 'image';\n  if (SUPPORTED_VIDEO_EXTENSIONS.includes(extension)) return 'video';\n  if (SUPPORTED_AUDIO_EXTENSIONS.includes(extension)) return 'audio';\n  return 'image'; // fallback\n}\n\nasync function generateThumbnail(imagePath: string): Promise<string> {\n  try {\n    const thumbnailPath = path.join(\n      path.dirname(imagePath),\n      '.thumbnails',\n      path.basename(imagePath, path.extname(imagePath)) + '_thumb.jpg'\n    );\n    \n    // Ensure thumbnail directory exists\n    await fs.mkdir(path.dirname(thumbnailPath), { recursive: true });\n    \n    // Generate thumbnail\n    await sharp(imagePath)\n      .resize(200, 200, { fit: 'inside', withoutEnlargement: true })\n      .jpeg({ quality: 80 })\n      .toFile(thumbnailPath);\n    \n    return path.relative(WORKSPACE_PATH, thumbnailPath);\n  } catch (error) {\n    console.error('Error generating thumbnail:', error);\n    return '';\n  }\n}\n\nexport async function tagImageWithAI(imagePath: string): Promise<string[]> {\n  try {\n    // For now, return basic tags based on filename\n    // In a real implementation, you would use LLaVA or similar vision model\n    const filename = path.basename(imagePath, path.extname(imagePath));\n    const tags: string[] = [];\n    \n    // Basic keyword extraction from filename\n    const keywords = filename.toLowerCase().split(/[-_\\s]+/);\n    tags.push(...keywords.filter(k => k.length > 2));\n    \n    // Add type-based tags\n    const ext = path.extname(imagePath).toLowerCase();\n    if (['.jpg', '.jpeg', '.png'].includes(ext)) {\n      tags.push('photo', 'image');\n    } else if (['.gif'].includes(ext)) {\n      tags.push('animation', 'gif');\n    } else if (['.svg'].includes(ext)) {\n      tags.push('vector', 'icon');\n    }\n    \n    return tags.slice(0, 10); // Limit to 10 tags\n  } catch (error) {\n    console.error('Error tagging image:', error);\n    return [];\n  }\n}\n\nexport async function findAssetUsage(assetPath: string): Promise<string[]> {\n  const usageFiles: string[] = [];\n  \n  try {\n    const assetName = path.basename(assetPath);\n    const assetNameWithoutExt = path.basename(assetPath, path.extname(assetPath));\n    \n    // Search patterns\n    const searchPatterns = [\n      assetName,\n      assetNameWithoutExt,\n      `\"${assetName}\"`,\n      `'${assetName}'`,\n      `/${assetName}`,\n      `./${assetName}`,\n    ];\n    \n    await searchInDirectory(WORKSPACE_PATH, searchPatterns, usageFiles);\n    \n    return usageFiles;\n  } catch (error) {\n    console.error('Error finding asset usage:', error);\n    return [];\n  }\n}\n\nasync function searchInDirectory(dirPath: string, patterns: string[], results: string[]): Promise<void> {\n  try {\n    const entries = await fs.readdir(dirPath, { withFileTypes: true });\n    \n    for (const entry of entries) {\n      const fullPath = path.join(dirPath, entry.name);\n      \n      if (entry.isDirectory() && !entry.name.startsWith('.') && entry.name !== 'node_modules') {\n        await searchInDirectory(fullPath, patterns, results);\n      } else if (entry.isFile()) {\n        const ext = path.extname(entry.name).toLowerCase();\n        \n        // Search in text files\n        if (['.js', '.jsx', '.ts', '.tsx', '.html', '.css', '.scss', '.json', '.md'].includes(ext)) {\n          try {\n            const content = await fs.readFile(fullPath, 'utf-8');\n            \n            for (const pattern of patterns) {\n              if (content.includes(pattern)) {\n                const relativePath = path.relative(WORKSPACE_PATH, fullPath);\n                if (!results.includes(relativePath)) {\n                  results.push(relativePath);\n                }\n              }\n            }\n          } catch (error) {\n            // Skip files that can't be read\n          }\n        }\n      }\n    }\n  } catch (error) {\n    console.error(`Error searching in directory ${dirPath}:`, error);\n  }\n}\n\nexport async function optimizeImage(imagePath: string, options: {\n  quality?: number;\n  maxWidth?: number;\n  maxHeight?: number;\n  format?: 'jpeg' | 'png' | 'webp';\n}): Promise<void> {\n  try {\n    const fullPath = path.join(WORKSPACE_PATH, imagePath);\n    const optimizedPath = path.join(\n      path.dirname(fullPath),\n      path.basename(fullPath, path.extname(fullPath)) + '_optimized.' + (options.format || 'jpg')\n    );\n    \n    let sharpInstance = sharp(fullPath);\n    \n    // Resize if needed\n    if (options.maxWidth || options.maxHeight) {\n      sharpInstance = sharpInstance.resize(options.maxWidth, options.maxHeight, {\n        fit: 'inside',\n        withoutEnlargement: true,\n      });\n    }\n    \n    // Apply format-specific optimizations\n    switch (options.format || 'jpeg') {\n      case 'jpeg':\n        sharpInstance = sharpInstance.jpeg({ quality: options.quality || 80 });\n        break;\n      case 'png':\n        sharpInstance = sharpInstance.png({ quality: options.quality || 80 });\n        break;\n      case 'webp':\n        sharpInstance = sharpInstance.webp({ quality: options.quality || 80 });\n        break;\n    }\n    \n    await sharpInstance.toFile(optimizedPath);\n    \n    // Optionally replace original\n    // await fs.rename(optimizedPath, fullPath);\n  } catch (error) {\n    console.error('Error optimizing image:', error);\n    throw error;\n  }\n}\n\nexport async function getMediaStats(): Promise<MediaStats> {\n  const mediaFiles = await getAllMediaFiles();\n  \n  const stats: MediaStats = {\n    totalFiles: mediaFiles.length,\n    totalSize: mediaFiles.reduce((sum, file) => sum + file.size, 0),\n    byType: {\n      image: mediaFiles.filter(f => f.type === 'image').length,\n      video: mediaFiles.filter(f => f.type === 'video').length,\n      audio: mediaFiles.filter(f => f.type === 'audio').length,\n    },\n    unusedFiles: 0,\n  };\n  \n  // Count unused files\n  for (const file of mediaFiles) {\n    const usage = await findAssetUsage(file.path);\n    if (usage.length === 0) {\n      stats.unusedFiles++;\n    }\n  }\n  \n  return stats;\n}\n\nexport async function detectUnusedAssets(): Promise<MediaFile[]> {\n  const mediaFiles = await getAllMediaFiles();\n  const unusedFiles: MediaFile[] = [];\n  \n  for (const file of mediaFiles) {\n    const usage = await findAssetUsage(file.path);\n    if (usage.length === 0) {\n      unusedFiles.push(file);\n    }\n  }\n  \n  return unusedFiles;\n}\n\n",
    "hash": "c0338e2a100388af9d0a961708527f26",
    "lastModified": "2025-10-27T08:27:34.506Z",
    "synced": false
  },
  {
    "id": "66126675a58684af1cdc8192af64c717",
    "type": "workspace",
    "path": "/workspace/backend/src/services/ollamaService.ts",
    "content": "import axios from 'axios';\nimport type { Socket, Server as SocketIOServer } from 'socket.io';\nimport { executeTool, getToolDefinitions, validateToolCall, type ToolCall } from '../tools/aiTools.js';\n\nconst OLLAMA_URL = process.env.OLLAMA_URL || 'http://localhost:11434';\nconst DEFAULT_MODEL = process.env.OLLAMA_MODEL || 'qwen2.5-coder:7b';\n\ninterface Message {\n  role: 'system' | 'user' | 'assistant';\n  content: string;\n  tool_calls?: ToolCall[];\n}\n\nexport function setupOllamaHandlers(socket: Socket, io: SocketIOServer) {\n  socket.on('chat:message', async (data: { id: string; content: string; context?: any }) => {\n    try {\n      // Validate input data\n      if (!data.id || !data.content) {\n        socket.emit('chat:error', { id: data.id, error: 'Missing required fields: id and content' });\n        return;\n      }\n\n      if (data.content.length > 10000) {\n        socket.emit('chat:error', { id: data.id, error: 'Message too long (max 10000 characters)' });\n        return;\n      }\n      const messages: Message[] = [\n        {\n          role: 'system',\n          content: getSystemPrompt(),\n        },\n        {\n          role: 'user',\n          content: data.content,\n        },\n      ];\n\n      // Check if the message contains tool requests\n      const toolDefinitions = getToolDefinitions();\n      const toolsPrompt = `\\n\\nAvailable tools:\\n${toolDefinitions.map(tool => \n        `- ${tool.name}: ${tool.description}`\n      ).join('\\n')}\\n\\nTo use a tool, respond with: TOOL_CALL: {\"name\": \"tool_name\", \"parameters\": {...}}`;\n\n      messages[1].content += toolsPrompt;\n\n      // Stream response from Ollama\n      const response = await axios.post(\n        `${OLLAMA_URL}/api/chat`,\n        {\n          model: DEFAULT_MODEL,\n          messages,\n          stream: true,\n        },\n        {\n          responseType: 'stream',\n        }\n      );\n\n      let fullResponse = '';\n      let toolCallBuffer = '';\n\n      response.data.on('data', async (chunk: Buffer) => {\n        const lines = chunk.toString().split('\\n').filter(line => line.trim());\n        \n        for (const line of lines) {\n          try {\n            const json = JSON.parse(line);\n            \n            if (json.message?.content) {\n              const content = json.message.content;\n              fullResponse += content;\n              \n              // Check for tool calls\n              if (content.includes('TOOL_CALL:')) {\n                toolCallBuffer += content;\n                \n                // Try to extract complete tool call\n                const toolCallMatch = toolCallBuffer.match(/TOOL_CALL:\\s*(\\{.*?\\})/s);\n                if (toolCallMatch) {\n                  try {\n                    const toolCallData = JSON.parse(toolCallMatch[1]);\n                    const toolCall: ToolCall = {\n                      id: `tool-${Date.now()}`,\n                      name: toolCallData.name,\n                      parameters: toolCallData.parameters,\n                      status: 'pending',\n                    };\n                    \n                    if (validateToolCall(toolCall)) {\n                      socket.emit('tool:start', toolCall);\n                      \n                      // Execute the tool\n                      const result = await executeTool(toolCall);\n                      socket.emit('tool:complete', result);\n                      \n                      // Send tool result back to AI\n                      const toolResultMessage = `Tool ${toolCall.name} executed successfully. Result: ${JSON.stringify(result.result)}`;\n                      fullResponse += `\\n\\n${toolResultMessage}`;\n                    }\n                    \n                    toolCallBuffer = '';\n                  } catch (parseError) {\n                    // Continue buffering if JSON is incomplete\n                  }\n                }\n              } else {\n                // Send regular content\n                socket.emit('chat:stream', {\n                  id: data.id,\n                  chunk: content,\n                });\n              }\n            }\n            \n            if (json.done) {\n              socket.emit('chat:complete', { id: data.id });\n            }\n          } catch (e) {\n            // Skip invalid JSON\n          }\n        }\n      });\n\n      response.data.on('end', () => {\n        socket.emit('chat:complete', { id: data.id });\n      });\n\n      response.data.on('error', (error: Error) => {\n        console.error('[Ollama] Stream error:', error);\n        socket.emit('chat:error', { id: data.id, error: error.message });\n      });\n    } catch (error: any) {\n      console.error('[Ollama] Error:', error);\n      socket.emit('chat:error', {\n        id: data.id,\n        error: error.message || 'Failed to get response from Ollama',\n      });\n    }\n  });\n\n  socket.on('generate:code', async (data: { id: string; prompt: string }) => {\n    try {\n      const response = await axios.post(\n        `${OLLAMA_URL}/api/generate`,\n        {\n          model: DEFAULT_MODEL,\n          prompt: `Generate code for: ${data.prompt}\\n\\nProvide only the code without explanations.`,\n          stream: true,\n        },\n        {\n          responseType: 'stream',\n        }\n      );\n\n      response.data.on('data', (chunk: Buffer) => {\n        const lines = chunk.toString().split('\\n').filter(line => line.trim());\n        \n        for (const line of lines) {\n          try {\n            const json = JSON.parse(line);\n            \n            if (json.response) {\n              socket.emit('chat:stream', {\n                id: data.id,\n                chunk: json.response,\n              });\n            }\n            \n            if (json.done) {\n              socket.emit(`generate:complete:${data.id}`);\n            }\n          } catch (e) {\n            // Skip invalid JSON\n          }\n        }\n      });\n\n      response.data.on('error', (error: Error) => {\n        socket.emit(`generate:error:${data.id}`, error.message);\n      });\n    } catch (error: any) {\n      socket.emit(`generate:error:${data.id}`, error.message);\n    }\n  });\n\n  socket.on('explain:error', async (data: { id: string; error: string; code: string }) => {\n    try {\n      const prompt = `Explain this error and suggest a fix:\\n\\nError: ${data.error}\\n\\nCode:\\n${data.code}`;\n      \n      const response = await axios.post(\n        `${OLLAMA_URL}/api/generate`,\n        {\n          model: DEFAULT_MODEL,\n          prompt,\n          stream: true,\n        },\n        {\n          responseType: 'stream',\n        }\n      );\n\n      response.data.on('data', (chunk: Buffer) => {\n        const lines = chunk.toString().split('\\n').filter(line => line.trim());\n        \n        for (const line of lines) {\n          try {\n            const json = JSON.parse(line);\n            \n            if (json.response) {\n              socket.emit('chat:stream', {\n                id: data.id,\n                chunk: json.response,\n              });\n            }\n            \n            if (json.done) {\n              socket.emit(`explain:complete:${data.id}`);\n            }\n          } catch (e) {\n            // Skip invalid JSON\n          }\n        }\n      });\n\n      response.data.on('error', (error: Error) => {\n        socket.emit(`explain:error:${data.id}`, error.message);\n      });\n    } catch (error: any) {\n      socket.emit(`explain:error:${data.id}`, error.message);\n    }\n  });\n}\n\nfunction getSystemPrompt(): string {\n  return `You are Tantra IDE's AI coding assistant powered by local LLM.\n\nYou have access to comprehensive tools:\n\nFILE OPERATIONS:\n- read_file(path) - Read file contents\n- write_file(path, content) - Create/update files\n- list_files(directory) - List directory contents\n- search_code(pattern, path) - Search with ripgrep\n\nEXECUTION:\n- run_command(cmd) - Execute terminal commands\n\nYour capabilities:\n1. Generate entire projects from descriptions\n2. Edit multiple files simultaneously\n3. Fix errors automatically\n4. Generate comprehensive tests\n5. Optimize code performance\n6. Manage dependencies\n7. Scan security issues\n\nGuidelines:\n- Always explain what you're doing\n- Be concise and accurate\n- Follow best practices and modern patterns\n- Add helpful comments\n- Be proactive with suggestions`;\n}\n\nexport async function checkOllamaConnection(): Promise<boolean> {\n  try {\n    await axios.get(`${OLLAMA_URL}/api/tags`);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport async function listModels(): Promise<any[]> {\n  try {\n    const response = await axios.get(`${OLLAMA_URL}/api/tags`);\n    return response.data.models || [];\n  } catch {\n    return [];\n  }\n}\n\n",
    "hash": "01f719ccc5a4c6265a46356ce96546b9",
    "lastModified": "2025-10-27T08:27:34.506Z",
    "synced": false
  },
  {
    "id": "bfb7ecc588ef48109df5b1c81aafa910",
    "type": "workspace",
    "path": "/workspace/backend/src/services/packageService.ts",
    "content": "import { exec } from 'child_process';\nimport { promisify } from 'util';\nimport fs from 'fs/promises';\nimport path from 'path';\n\nconst execAsync = promisify(exec);\n\nconst WORKSPACE_PATH = process.env.WORKSPACE_PATH || process.cwd();\n\nexport interface PackageInfo {\n  name: string;\n  version: string;\n  description?: string;\n  latest?: string;\n  outdated: boolean;\n  dependencies?: Record<string, string>;\n}\n\nexport interface DependencyTree {\n  name: string;\n  version: string;\n  dependencies: DependencyTree[];\n}\n\nexport async function detectPackageManager(): Promise<string | null> {\n  try {\n    const packageJsonPath = path.join(WORKSPACE_PATH, 'package.json');\n    const requirementsPath = path.join(WORKSPACE_PATH, 'requirements.txt');\n    const cargoPath = path.join(WORKSPACE_PATH, 'Cargo.toml');\n    const goModPath = path.join(WORKSPACE_PATH, 'go.mod');\n    \n    if (await fileExists(packageJsonPath)) return 'npm';\n    if (await fileExists(requirementsPath)) return 'pip';\n    if (await fileExists(cargoPath)) return 'cargo';\n    if (await fileExists(goModPath)) return 'go';\n    \n    return null;\n  } catch {\n    return null;\n  }\n}\n\nexport async function detectMissingDependencies(): Promise<string[]> {\n  const manager = await detectPackageManager();\n  if (!manager) return [];\n  \n  try {\n    switch (manager) {\n      case 'npm':\n        return await detectMissingNpmDeps();\n      case 'pip':\n        return await detectMissingPipDeps();\n      case 'cargo':\n        return await detectMissingCargoDeps();\n      case 'go':\n        return await detectMissingGoDeps();\n      default:\n        return [];\n    }\n  } catch (error) {\n    console.error('Error detecting missing dependencies:', error);\n    return [];\n  }\n}\n\nasync function detectMissingNpmDeps(): Promise<string[]> {\n  try {\n    const { stdout } = await execAsync('npm ls --depth=0 --json', {\n      cwd: WORKSPACE_PATH,\n    });\n    \n    const packageJson = JSON.parse(await fs.readFile(path.join(WORKSPACE_PATH, 'package.json'), 'utf-8'));\n    const installed = JSON.parse(stdout);\n    \n    const missing: string[] = [];\n    const dependencies = { ...packageJson.dependencies, ...packageJson.devDependencies };\n    \n    for (const [name, version] of Object.entries(dependencies)) {\n      if (!installed.dependencies?.[name]) {\n        missing.push(name);\n      }\n    }\n    \n    return missing;\n  } catch {\n    return [];\n  }\n}\n\nasync function detectMissingPipDeps(): Promise<string[]> {\n  try {\n    const requirements = await fs.readFile(path.join(WORKSPACE_PATH, 'requirements.txt'), 'utf-8');\n    const packages = requirements.split('\\n')\n      .map(line => line.trim())\n      .filter(line => line && !line.startsWith('#'))\n      .map(line => line.split('==')[0].split('>=')[0].split('<=')[0]);\n    \n    const missing: string[] = [];\n    \n    for (const pkg of packages) {\n      try {\n        await execAsync(`python -c \"import ${pkg}\"`);\n      } catch {\n        missing.push(pkg);\n      }\n    }\n    \n    return missing;\n  } catch {\n    return [];\n  }\n}\n\nasync function detectMissingCargoDeps(): Promise<string[]> {\n  try {\n    await execAsync('cargo check', { cwd: WORKSPACE_PATH });\n    return [];\n  } catch {\n    return ['cargo dependencies'];\n  }\n}\n\nasync function detectMissingGoDeps(): Promise<string[]> {\n  try {\n    await execAsync('go mod tidy', { cwd: WORKSPACE_PATH });\n    return [];\n  } catch {\n    return ['go dependencies'];\n  }\n}\n\nexport async function installPackage(packageName: string, manager: string = 'npm'): Promise<void> {\n  try {\n    let command: string;\n    \n    switch (manager) {\n      case 'npm':\n        command = `npm install ${packageName}`;\n        break;\n      case 'pip':\n        command = `pip install ${packageName}`;\n        break;\n      case 'cargo':\n        command = `cargo add ${packageName}`;\n        break;\n      case 'go':\n        command = `go get ${packageName}`;\n        break;\n      default:\n        throw new Error(`Unsupported package manager: ${manager}`);\n    }\n    \n    await execAsync(command, { cwd: WORKSPACE_PATH });\n  } catch (error) {\n    console.error(`Error installing package ${packageName}:`, error);\n    throw error;\n  }\n}\n\nexport async function getDependencyTree(manager: string = 'npm'): Promise<DependencyTree | null> {\n  try {\n    switch (manager) {\n      case 'npm':\n        return await getNpmDependencyTree();\n      case 'pip':\n        return await getPipDependencyTree();\n      case 'cargo':\n        return await getCargoDependencyTree();\n      case 'go':\n        return await getGoDependencyTree();\n      default:\n        return null;\n    }\n  } catch (error) {\n    console.error('Error getting dependency tree:', error);\n    return null;\n  }\n}\n\nasync function getNpmDependencyTree(): Promise<DependencyTree | null> {\n  try {\n    const { stdout } = await execAsync('npm ls --json', { cwd: WORKSPACE_PATH });\n    const tree = JSON.parse(stdout);\n    \n    return {\n      name: tree.name || 'root',\n      version: tree.version || '1.0.0',\n      dependencies: Object.values(tree.dependencies || {}).map((dep: any) => ({\n        name: dep.name,\n        version: dep.version,\n        dependencies: Object.values(dep.dependencies || {}).map((subDep: any) => ({\n          name: subDep.name,\n          version: subDep.version,\n          dependencies: [],\n        })),\n      })),\n    };\n  } catch {\n    return null;\n  }\n}\n\nasync function getPipDependencyTree(): Promise<DependencyTree | null> {\n  try {\n    const { stdout } = await execAsync('pip list --format=json', { cwd: WORKSPACE_PATH });\n    const packages = JSON.parse(stdout);\n    \n    return {\n      name: 'python-packages',\n      version: '1.0.0',\n      dependencies: packages.map((pkg: any) => ({\n        name: pkg.name,\n        version: pkg.version,\n        dependencies: [],\n      })),\n    };\n  } catch {\n    return null;\n  }\n}\n\nasync function getCargoDependencyTree(): Promise<DependencyTree | null> {\n  try {\n    const { stdout } = await execAsync('cargo tree --format \"{p} {v}\"', { cwd: WORKSPACE_PATH });\n    const lines = stdout.split('\\n').filter(line => line.trim());\n    \n    return {\n      name: 'cargo-dependencies',\n      version: '1.0.0',\n      dependencies: lines.map(line => {\n        const [name, version] = line.split(' ');\n        return {\n          name,\n          version,\n          dependencies: [],\n        };\n      }),\n    };\n  } catch {\n    return null;\n  }\n}\n\nasync function getGoDependencyTree(): Promise<DependencyTree | null> {\n  try {\n    const { stdout } = await execAsync('go list -m all', { cwd: WORKSPACE_PATH });\n    const lines = stdout.split('\\n').filter(line => line.trim());\n    \n    return {\n      name: 'go-modules',\n      version: '1.0.0',\n      dependencies: lines.map(line => {\n        const parts = line.split(' ');\n        return {\n          name: parts[0],\n          version: parts[1] || 'latest',\n          dependencies: [],\n        };\n      }),\n    };\n  } catch {\n    return null;\n  }\n}\n\nexport async function updatePackages(manager: string = 'npm'): Promise<void> {\n  try {\n    let command: string;\n    \n    switch (manager) {\n      case 'npm':\n        command = 'npm update';\n        break;\n      case 'pip':\n        command = 'pip install --upgrade pip && pip list --outdated --format=freeze | grep -v \"^\\-e\" | cut -d = -f 1 | xargs -n1 pip install -U';\n        break;\n      case 'cargo':\n        command = 'cargo update';\n        break;\n      case 'go':\n        command = 'go get -u ./...';\n        break;\n      default:\n        throw new Error(`Unsupported package manager: ${manager}`);\n    }\n    \n    await execAsync(command, { cwd: WORKSPACE_PATH });\n  } catch (error) {\n    console.error('Error updating packages:', error);\n    throw error;\n  }\n}\n\nasync function fileExists(filePath: string): Promise<boolean> {\n  try {\n    await fs.access(filePath);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n",
    "hash": "ceb831dcf284223e73e841598f3ccfcc",
    "lastModified": "2025-10-27T08:27:34.506Z",
    "synced": false
  },
  {
    "id": "4c9f3485b02244becbe1e592baf4a00f",
    "type": "workspace",
    "path": "/workspace/backend/src/services/performanceService.ts",
    "content": "import { exec } from 'child_process';\nimport { promisify } from 'util';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport axios from 'axios';\n\nconst execAsync = promisify(exec);\nconst WORKSPACE_PATH = process.env.WORKSPACE_PATH || process.cwd();\n\nexport interface BundleAnalysis {\n  totalSize: number;\n  gzippedSize: number;\n  files: BundleFile[];\n  chunks: BundleChunk[];\n  assets: BundleAsset[];\n  duplicates: DuplicateModule[];\n  recommendations: string[];\n}\n\nexport interface BundleFile {\n  name: string;\n  size: number;\n  gzippedSize: number;\n  type: string;\n  path: string;\n}\n\nexport interface BundleChunk {\n  name: string;\n  size: number;\n  modules: number;\n  files: string[];\n}\n\nexport interface BundleAsset {\n  name: string;\n  size: number;\n  type: string;\n  chunks: string[];\n}\n\nexport interface DuplicateModule {\n  name: string;\n  instances: number;\n  totalSize: number;\n  files: string[];\n}\n\nexport interface PerformanceMetrics {\n  loadTime: number;\n  firstContentfulPaint: number;\n  largestContentfulPaint: number;\n  firstInputDelay: number;\n  cumulativeLayoutShift: number;\n  speedIndex: number;\n  totalBlockingTime: number;\n}\n\nexport interface LighthouseReport {\n  performance: number;\n  accessibility: number;\n  bestPractices: number;\n  seo: number;\n  metrics: PerformanceMetrics;\n  opportunities: OptimizationOpportunity[];\n  diagnostics: Diagnostic[];\n}\n\nexport interface OptimizationOpportunity {\n  id: string;\n  title: string;\n  description: string;\n  score: number;\n  savings: {\n    bytes?: number;\n    ms?: number;\n  };\n}\n\nexport interface Diagnostic {\n  id: string;\n  title: string;\n  description: string;\n  score: number;\n}\n\n// Bundle Analysis\nexport async function analyzeBundle(): Promise<BundleAnalysis> {\n  try {\n    // Check if webpack-bundle-analyzer is available\n    let analyzerPath: string;\n    try {\n      await execAsync('npx webpack-bundle-analyzer --version', { cwd: WORKSPACE_PATH });\n      analyzerPath = 'npx webpack-bundle-analyzer';\n    } catch {\n      // Try to install it\n      await execAsync('npm install -g webpack-bundle-analyzer', { cwd: WORKSPACE_PATH });\n      analyzerPath = 'webpack-bundle-analyzer';\n    }\n\n    // Generate bundle stats\n    const buildCommand = await detectBuildCommand();\n    await execAsync(buildCommand, { cwd: WORKSPACE_PATH });\n\n    // Analyze bundle\n    const { stdout } = await execAsync(`${analyzerPath} --mode static --report`, { cwd: WORKSPACE_PATH });\n    \n    // Parse the analysis (simplified version)\n    const analysis = await parseBundleAnalysis();\n    \n    return analysis;\n  } catch (error) {\n    console.error('Bundle analysis error:', error);\n    return createEmptyBundleAnalysis();\n  }\n}\n\nasync function detectBuildCommand(): Promise<string> {\n  try {\n    const packageJson = JSON.parse(await fs.readFile(path.join(WORKSPACE_PATH, 'package.json'), 'utf-8'));\n    \n    if (packageJson.scripts?.build) {\n      return 'npm run build';\n    } else if (packageJson.scripts?.['build:prod']) {\n      return 'npm run build:prod';\n    } else if (packageJson.scripts?.webpack) {\n      return 'npm run webpack';\n    } else {\n      return 'npm run build';\n    }\n  } catch {\n    return 'npm run build';\n  }\n}\n\nasync function parseBundleAnalysis(): Promise<BundleAnalysis> {\n  // In a real implementation, this would parse the actual bundle analyzer output\n  // For now, we'll create a mock analysis\n  return {\n    totalSize: 1024 * 1024, // 1MB\n    gzippedSize: 256 * 1024, // 256KB\n    files: [\n      {\n        name: 'main.js',\n        size: 512 * 1024,\n        gzippedSize: 128 * 1024,\n        type: 'js',\n        path: '/dist/main.js',\n      },\n      {\n        name: 'vendor.js',\n        size: 256 * 1024,\n        gzippedSize: 64 * 1024,\n        type: 'js',\n        path: '/dist/vendor.js',\n      },\n    ],\n    chunks: [\n      {\n        name: 'main',\n        size: 512 * 1024,\n        modules: 150,\n        files: ['main.js'],\n      },\n      {\n        name: 'vendor',\n        size: 256 * 1024,\n        modules: 50,\n        files: ['vendor.js'],\n      },\n    ],\n    assets: [\n      {\n        name: 'main.js',\n        size: 512 * 1024,\n        type: 'js',\n        chunks: ['main'],\n      },\n    ],\n    duplicates: [\n      {\n        name: 'lodash',\n        instances: 2,\n        totalSize: 64 * 1024,\n        files: ['main.js', 'vendor.js'],\n      },\n    ],\n    recommendations: [\n      'Remove duplicate lodash imports',\n      'Consider code splitting for large chunks',\n      'Enable gzip compression',\n    ],\n  };\n}\n\nfunction createEmptyBundleAnalysis(): BundleAnalysis {\n  return {\n    totalSize: 0,\n    gzippedSize: 0,\n    files: [],\n    chunks: [],\n    assets: [],\n    duplicates: [],\n    recommendations: [],\n  };\n}\n\n// Performance Profiling\nexport async function runPerformanceProfile(url?: string): Promise<LighthouseReport> {\n  try {\n    // Check if Lighthouse CLI is available\n    try {\n      await execAsync('lighthouse --version', { cwd: WORKSPACE_PATH });\n    } catch {\n      // Install Lighthouse CLI\n      await execAsync('npm install -g lighthouse', { cwd: WORKSPACE_PATH });\n    }\n\n    const targetUrl = url || 'http://localhost:3000';\n    \n    // Run Lighthouse audit\n    const { stdout } = await execAsync(`lighthouse ${targetUrl} --output=json --chrome-flags=\"--headless\"`, { \n      cwd: WORKSPACE_PATH \n    });\n    \n    const report = JSON.parse(stdout);\n    \n    return {\n      performance: report.categories.performance.score * 100,\n      accessibility: report.categories.accessibility.score * 100,\n      bestPractices: report.categories['best-practices'].score * 100,\n      seo: report.categories.seo.score * 100,\n      metrics: {\n        loadTime: report.audits['first-contentful-paint'].numericValue,\n        firstContentfulPaint: report.audits['first-contentful-paint'].numericValue,\n        largestContentfulPaint: report.audits['largest-contentful-paint'].numericValue,\n        firstInputDelay: report.audits['max-potential-fid'].numericValue,\n        cumulativeLayoutShift: report.audits['cumulative-layout-shift'].numericValue,\n        speedIndex: report.audits['speed-index'].numericValue,\n        totalBlockingTime: report.audits['total-blocking-time'].numericValue,\n      },\n      opportunities: report.categories.performance.auditRefs\n        .filter((ref: any) => ref.group === 'load-opportunities')\n        .map((ref: any) => ({\n          id: ref.id,\n          title: report.audits[ref.id].title,\n          description: report.audits[ref.id].description,\n          score: report.audits[ref.id].score,\n          savings: report.audits[ref.id].details?.overallSavingsMs || {},\n        })),\n      diagnostics: report.categories.performance.auditRefs\n        .filter((ref: any) => ref.group === 'diagnostics')\n        .map((ref: any) => ({\n          id: ref.id,\n          title: report.audits[ref.id].title,\n          description: report.audits[ref.id].description,\n          score: report.audits[ref.id].score,\n        })),\n    };\n  } catch (error) {\n    console.error('Performance profiling error:', error);\n    return createEmptyLighthouseReport();\n  }\n}\n\nfunction createEmptyLighthouseReport(): LighthouseReport {\n  return {\n    performance: 0,\n    accessibility: 0,\n    bestPractices: 0,\n    seo: 0,\n    metrics: {\n      loadTime: 0,\n      firstContentfulPaint: 0,\n      largestContentfulPaint: 0,\n      firstInputDelay: 0,\n      cumulativeLayoutShift: 0,\n      speedIndex: 0,\n      totalBlockingTime: 0,\n    },\n    opportunities: [],\n    diagnostics: [],\n  };\n}\n\n// Memory Profiling\nexport async function runMemoryProfile(): Promise<any> {\n  try {\n    // Use Node.js built-in memory profiling\n    const memUsage = process.memoryUsage();\n    \n    return {\n      rss: memUsage.rss,\n      heapTotal: memUsage.heapTotal,\n      heapUsed: memUsage.heapUsed,\n      external: memUsage.external,\n      arrayBuffers: memUsage.arrayBuffers,\n      timestamp: new Date().toISOString(),\n    };\n  } catch (error) {\n    console.error('Memory profiling error:', error);\n    return null;\n  }\n}\n\n// CPU Profiling\nexport async function runCPUProfile(duration: number = 10000): Promise<any> {\n  try {\n    // Start CPU profiling\n    const profiler = await import('v8-profiler-next');\n    profiler.default.startProfiling('CPU Profile');\n    \n    // Wait for specified duration\n    await new Promise(resolve => setTimeout(resolve, duration));\n    \n    // Stop profiling\n    const profile = profiler.default.stopProfiling('CPU Profile');\n    \n    return {\n      profile: profile,\n      duration: duration,\n      timestamp: new Date().toISOString(),\n    };\n  } catch (error) {\n    console.error('CPU profiling error:', error);\n    return null;\n  }\n}\n\n// Network Analysis\nexport async function analyzeNetworkRequests(url?: string): Promise<any> {\n  try {\n    const targetUrl = url || 'http://localhost:3000';\n    \n    // Use Puppeteer to analyze network requests\n    const puppeteer = await import('puppeteer');\n    const browser = await puppeteer.default.launch({ headless: true });\n    const page = await browser.newPage();\n    \n    const requests: any[] = [];\n    const responses: any[] = [];\n    \n    page.on('request', request => {\n      requests.push({\n        url: request.url(),\n        method: request.method(),\n        headers: request.headers(),\n        timestamp: Date.now(),\n      });\n    });\n    \n    page.on('response', response => {\n      responses.push({\n        url: response.url(),\n        status: response.status(),\n        headers: response.headers(),\n        timestamp: Date.now(),\n      });\n    });\n    \n    await page.goto(targetUrl);\n    // Wait for page to load\n    await new Promise(resolve => setTimeout(resolve, 2000));\n    \n    await browser.close();\n    \n    return {\n      requests,\n      responses,\n      totalRequests: requests.length,\n      totalSize: responses.reduce((sum, res) => sum + (res.headers['content-length'] || 0), 0),\n    };\n  } catch (error) {\n    console.error('Network analysis error:', error);\n    return null;\n  }\n}\n\n// Performance Optimization Suggestions\nexport async function getOptimizationSuggestions(bundleAnalysis: BundleAnalysis, lighthouseReport: LighthouseReport): Promise<string[]> {\n  const suggestions: string[] = [];\n  \n  // Bundle optimization suggestions\n  if (bundleAnalysis.totalSize > 1024 * 1024) {\n    suggestions.push('Bundle size is large (>1MB). Consider code splitting.');\n  }\n  \n  if (bundleAnalysis.duplicates.length > 0) {\n    suggestions.push(`Found ${bundleAnalysis.duplicates.length} duplicate modules. Consider deduplication.`);\n  }\n  \n  if (bundleAnalysis.gzippedSize / bundleAnalysis.totalSize < 0.3) {\n    suggestions.push('Enable gzip compression to reduce bundle size.');\n  }\n  \n  // Performance suggestions\n  if (lighthouseReport.performance < 90) {\n    suggestions.push('Performance score is below 90. Optimize loading times.');\n  }\n  \n  if (lighthouseReport.metrics.firstContentfulPaint > 2000) {\n    suggestions.push('First Contentful Paint is slow. Optimize critical rendering path.');\n  }\n  \n  if (lighthouseReport.metrics.largestContentfulPaint > 4000) {\n    suggestions.push('Largest Contentful Paint is slow. Optimize images and fonts.');\n  }\n  \n  if (lighthouseReport.metrics.cumulativeLayoutShift > 0.1) {\n    suggestions.push('High Cumulative Layout Shift. Fix layout shifts.');\n  }\n  \n  return suggestions;\n}\n\n// Generate Performance Report\nexport async function generatePerformanceReport(): Promise<any> {\n  try {\n    const [bundleAnalysis, lighthouseReport, memoryProfile] = await Promise.all([\n      analyzeBundle(),\n      runPerformanceProfile(),\n      runMemoryProfile(),\n    ]);\n    \n    const suggestions = await getOptimizationSuggestions(bundleAnalysis, lighthouseReport);\n    \n    return {\n      bundle: bundleAnalysis,\n      lighthouse: lighthouseReport,\n      memory: memoryProfile,\n      suggestions,\n      timestamp: new Date().toISOString(),\n    };\n  } catch (error) {\n    console.error('Performance report generation error:', error);\n    return null;\n  }\n}\n\n",
    "hash": "abb11ccc146b4e8ead40194e5e206c61",
    "lastModified": "2025-10-27T08:51:03.362Z",
    "synced": false
  },
  {
    "id": "de61f64d619155b941a274b96f3605e6",
    "type": "workspace",
    "path": "/workspace/backend/src/services/pluginService.ts",
    "content": "import { exec } from 'child_process';\nimport { promisify } from 'util';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport axios from 'axios';\n\nconst execAsync = promisify(exec);\n\nexport interface Plugin {\n  id: string;\n  name: string;\n  version: string;\n  description: string;\n  author: string;\n  enabled: boolean;\n  path: string;\n  manifest: PluginManifest;\n  dependencies: string[];\n  commands: PluginCommand[];\n  keybindings: PluginKeybinding[];\n  views: PluginView[];\n  languages: PluginLanguage[];\n}\n\nexport interface PluginManifest {\n  name: string;\n  version: string;\n  description: string;\n  author: string;\n  main: string;\n  dependencies?: Record<string, string>;\n  commands?: PluginCommand[];\n  keybindings?: PluginKeybinding[];\n  views?: PluginView[];\n  languages?: PluginLanguage[];\n  activationEvents?: string[];\n}\n\nexport interface PluginCommand {\n  command: string;\n  title: string;\n  category?: string;\n  icon?: string;\n  handler: string;\n}\n\nexport interface PluginKeybinding {\n  key: string;\n  command: string;\n  when?: string;\n}\n\nexport interface PluginView {\n  id: string;\n  name: string;\n  type: 'panel' | 'sidebar' | 'statusbar';\n  location: string;\n  component: string;\n}\n\nexport interface PluginLanguage {\n  id: string;\n  extensions: string[];\n  configuration?: any;\n}\n\nexport interface PluginContext {\n  workspace: string;\n  files: string[];\n  activeFile?: string;\n  selection?: string;\n  clipboard?: string;\n}\n\nclass PluginManager {\n  private plugins: Map<string, Plugin> = new Map();\n  private pluginDir: string;\n  private loadedPlugins: Map<string, any> = new Map();\n\n  constructor() {\n    this.pluginDir = path.join(process.cwd(), 'plugins');\n    this.initializePluginDirectory();\n  }\n\n  private async initializePluginDirectory() {\n    try {\n      await fs.mkdir(this.pluginDir, { recursive: true });\n    } catch (error) {\n      console.error('Failed to create plugin directory:', error);\n    }\n  }\n\n  async loadPlugin(pluginPath: string): Promise<Plugin> {\n    try {\n      const manifestPath = path.join(pluginPath, 'package.json');\n      const manifestContent = await fs.readFile(manifestPath, 'utf-8');\n      const manifest: PluginManifest = JSON.parse(manifestContent);\n\n      const plugin: Plugin = {\n        id: manifest.name,\n        name: manifest.name,\n        version: manifest.version,\n        description: manifest.description,\n        author: manifest.author,\n        enabled: true,\n        path: pluginPath,\n        manifest,\n        dependencies: Object.keys(manifest.dependencies || {}),\n        commands: manifest.commands || [],\n        keybindings: manifest.keybindings || [],\n        views: manifest.views || [],\n        languages: manifest.languages || [],\n      };\n\n      // Load the plugin module\n      const pluginModule = await import(path.join(pluginPath, manifest.main));\n      this.loadedPlugins.set(plugin.id, pluginModule);\n\n      this.plugins.set(plugin.id, plugin);\n      return plugin;\n    } catch (error) {\n      console.error(`Failed to load plugin from ${pluginPath}:`, error);\n      throw error;\n    }\n  }\n\n  async loadAllPlugins(): Promise<Plugin[]> {\n    try {\n      const entries = await fs.readdir(this.pluginDir, { withFileTypes: true });\n      const pluginDirs = entries\n        .filter(entry => entry.isDirectory())\n        .map(entry => path.join(this.pluginDir, entry.name));\n\n      const plugins: Plugin[] = [];\n      for (const pluginDir of pluginDirs) {\n        try {\n          const plugin = await this.loadPlugin(pluginDir);\n          plugins.push(plugin);\n        } catch (error) {\n          console.error(`Failed to load plugin from ${pluginDir}:`, error);\n        }\n      }\n\n      return plugins;\n    } catch (error) {\n      console.error('Failed to load plugins:', error);\n      return [];\n    }\n  }\n\n  async installPlugin(packageName: string, version?: string): Promise<Plugin> {\n    try {\n      const installCommand = version \n        ? `npm install ${packageName}@${version}`\n        : `npm install ${packageName}`;\n\n      // Install to plugin directory\n      await execAsync(installCommand, { cwd: this.pluginDir });\n\n      // Find the installed plugin\n      const pluginPath = path.join(this.pluginDir, 'node_modules', packageName);\n      const plugin = await this.loadPlugin(pluginPath);\n\n      return plugin;\n    } catch (error) {\n      console.error(`Failed to install plugin ${packageName}:`, error);\n      throw error;\n    }\n  }\n\n  async uninstallPlugin(pluginId: string): Promise<void> {\n    const plugin = this.plugins.get(pluginId);\n    if (!plugin) {\n      throw new Error(`Plugin ${pluginId} not found`);\n    }\n\n    try {\n      // Remove from node_modules\n      const pluginPath = path.join(this.pluginDir, 'node_modules', pluginId);\n      await fs.rm(pluginPath, { recursive: true, force: true });\n\n      // Remove from loaded plugins\n      this.plugins.delete(pluginId);\n      this.loadedPlugins.delete(pluginId);\n    } catch (error) {\n      console.error(`Failed to uninstall plugin ${pluginId}:`, error);\n      throw error;\n    }\n  }\n\n  async enablePlugin(pluginId: string): Promise<void> {\n    const plugin = this.plugins.get(pluginId);\n    if (plugin) {\n      plugin.enabled = true;\n      await this.activatePlugin(pluginId);\n    }\n  }\n\n  async disablePlugin(pluginId: string): Promise<void> {\n    const plugin = this.plugins.get(pluginId);\n    if (plugin) {\n      plugin.enabled = false;\n      await this.deactivatePlugin(pluginId);\n    }\n  }\n\n  async activatePlugin(pluginId: string): Promise<void> {\n    const plugin = this.plugins.get(pluginId);\n    const pluginModule = this.loadedPlugins.get(pluginId);\n\n    if (plugin && pluginModule && plugin.enabled) {\n      try {\n        if (pluginModule.activate) {\n          await pluginModule.activate();\n        }\n      } catch (error) {\n        console.error(`Failed to activate plugin ${pluginId}:`, error);\n      }\n    }\n  }\n\n  async deactivatePlugin(pluginId: string): Promise<void> {\n    const pluginModule = this.loadedPlugins.get(pluginId);\n\n    if (pluginModule) {\n      try {\n        if (pluginModule.deactivate) {\n          await pluginModule.deactivate();\n        }\n      } catch (error) {\n        console.error(`Failed to deactivate plugin ${pluginId}:`, error);\n      }\n    }\n  }\n\n  async executeCommand(command: string, context: PluginContext): Promise<any> {\n    for (const plugin of this.plugins.values()) {\n      if (!plugin.enabled) continue;\n\n      const commandDef = plugin.commands.find(cmd => cmd.command === command);\n      if (commandDef) {\n        const pluginModule = this.loadedPlugins.get(plugin.id);\n        if (pluginModule && pluginModule[commandDef.handler]) {\n          return await pluginModule[commandDef.handler](context);\n        }\n      }\n    }\n\n    throw new Error(`Command ${command} not found`);\n  }\n\n  getPlugins(): Plugin[] {\n    return Array.from(this.plugins.values());\n  }\n\n  getPlugin(pluginId: string): Plugin | undefined {\n    return this.plugins.get(pluginId);\n  }\n\n  getCommands(): PluginCommand[] {\n    const commands: PluginCommand[] = [];\n    for (const plugin of this.plugins.values()) {\n      if (plugin.enabled) {\n        commands.push(...plugin.commands);\n      }\n    }\n    return commands;\n  }\n\n  getKeybindings(): PluginKeybinding[] {\n    const keybindings: PluginKeybinding[] = [];\n    for (const plugin of this.plugins.values()) {\n      if (plugin.enabled) {\n        keybindings.push(...plugin.keybindings);\n      }\n    }\n    return keybindings;\n  }\n\n  getViews(): PluginView[] {\n    const views: PluginView[] = [];\n    for (const plugin of this.plugins.values()) {\n      if (plugin.enabled) {\n        views.push(...plugin.views);\n      }\n    }\n    return views;\n  }\n\n  getLanguages(): PluginLanguage[] {\n    const languages: PluginLanguage[] = [];\n    for (const plugin of this.plugins.values()) {\n      if (plugin.enabled) {\n        languages.push(...plugin.languages);\n      }\n    }\n    return languages;\n  }\n}\n\nexport const pluginManager = new PluginManager();",
    "hash": "89579c9e5a643d2f5a4fe4cdf1dd2ee6",
    "lastModified": "2025-10-27T08:27:34.506Z",
    "synced": false
  },
  {
    "id": "f595dc15fccf32a8468a83cdc4b2dfce",
    "type": "workspace",
    "path": "/workspace/backend/src/services/searchService.ts",
    "content": "import axios from 'axios';\n\nexport interface SearchResult {\n  id: string;\n  title: string;\n  description: string;\n  url: string;\n  source: 'stackoverflow' | 'github' | 'npm' | 'mdn' | 'web';\n  score?: number;\n  tags?: string[];\n  author?: string;\n  createdAt?: string;\n  language?: string;\n}\n\nexport interface SearchOptions {\n  limit?: number;\n  language?: string;\n  sortBy?: 'relevance' | 'date' | 'stars' | 'downloads';\n}\n\n// Stack Overflow Search\nexport async function searchStackOverflow(query: string, options: SearchOptions = {}): Promise<SearchResult[]> {\n  try {\n    const params = new URLSearchParams({\n      order: 'desc',\n      sort: options.sortBy === 'date' ? 'creation' : 'relevance',\n      intitle: query,\n      site: 'stackoverflow',\n      pagesize: (options.limit || 10).toString(),\n    });\n\n    if (options.language) {\n      params.append('tagged', options.language);\n    }\n\n    const response = await axios.get(`https://api.stackexchange.com/2.3/search/advanced?${params}`);\n    \n    return response.data.items.map((item: any) => ({\n      id: `so-${item.question_id}`,\n      title: item.title,\n      description: item.excerpt || '',\n      url: item.link,\n      source: 'stackoverflow' as const,\n      score: item.score,\n      tags: item.tags,\n      author: item.owner?.display_name,\n      createdAt: new Date(item.creation_date * 1000).toISOString(),\n    }));\n  } catch (error) {\n    console.error('Stack Overflow search error:', error);\n    return [];\n  }\n}\n\n// GitHub Search\nexport async function searchGitHub(query: string, options: SearchOptions = {}): Promise<SearchResult[]> {\n  try {\n    const params = new URLSearchParams({\n      q: query,\n      sort: options.sortBy === 'stars' ? 'stars' : 'best match',\n      order: 'desc',\n      per_page: (options.limit || 10).toString(),\n    });\n\n    if (options.language) {\n      params.append('language', options.language);\n    }\n\n    const response = await axios.get(`https://api.github.com/search/repositories?${params}`);\n    \n    return response.data.items.map((item: any) => ({\n      id: `gh-${item.id}`,\n      title: item.name,\n      description: item.description || '',\n      url: item.html_url,\n      source: 'github' as const,\n      score: item.stargazers_count,\n      language: item.language,\n      author: item.owner?.login,\n      createdAt: item.created_at,\n    }));\n  } catch (error) {\n    console.error('GitHub search error:', error);\n    return [];\n  }\n}\n\n// NPM Search\nexport async function searchNPM(query: string, options: SearchOptions = {}): Promise<SearchResult[]> {\n  try {\n    const params = new URLSearchParams({\n      text: query,\n      size: (options.limit || 10).toString(),\n    });\n\n    const response = await axios.get(`https://registry.npmjs.org/-/v1/search?${params}`);\n    \n    return response.data.objects.map((item: any) => ({\n      id: `npm-${item.package.name}`,\n      title: item.package.name,\n      description: item.package.description || '',\n      url: `https://www.npmjs.com/package/${item.package.name}`,\n      source: 'npm' as const,\n      score: item.score?.final || 0,\n      author: item.package.author?.name,\n      createdAt: item.package.date,\n    }));\n  } catch (error) {\n    console.error('NPM search error:', error);\n    return [];\n  }\n}\n\n// MDN Search\nexport async function searchMDN(query: string, options: SearchOptions = {}): Promise<SearchResult[]> {\n  try {\n    const params = new URLSearchParams({\n      q: query,\n      locale: 'en-US',\n    });\n\n    const response = await axios.get(`https://developer.mozilla.org/api/v1/search?${params}`);\n    \n    return response.data.documents.slice(0, options.limit || 10).map((item: any) => ({\n      id: `mdn-${item.id}`,\n      title: item.title,\n      description: item.summary || '',\n      url: `https://developer.mozilla.org${item.mdn_url}`,\n      source: 'mdn' as const,\n      score: item.score,\n      tags: item.tags,\n    }));\n  } catch (error) {\n    console.error('MDN search error:', error);\n    return [];\n  }\n}\n\n// General Web Search (using DuckDuckGo Instant Answer API)\nexport async function searchWeb(query: string, options: SearchOptions = {}): Promise<SearchResult[]> {\n  try {\n    const params = new URLSearchParams({\n      q: query,\n      format: 'json',\n      no_html: '1',\n      skip_disambig: '1',\n    });\n\n    const response = await axios.get(`https://api.duckduckgo.com/?${params}`);\n    \n    const results: SearchResult[] = [];\n    \n    // Add abstract if available\n    if (response.data.Abstract) {\n      results.push({\n        id: `web-abstract-${Date.now()}`,\n        title: response.data.Heading || query,\n        description: response.data.Abstract,\n        url: response.data.AbstractURL || '',\n        source: 'web' as const,\n        score: 1,\n      });\n    }\n    \n    // Add related topics\n    if (response.data.RelatedTopics) {\n      response.data.RelatedTopics.slice(0, options.limit || 5).forEach((topic: any, index: number) => {\n        if (topic.Text && topic.FirstURL) {\n          results.push({\n            id: `web-topic-${index}`,\n            title: topic.Text.split(' - ')[0] || topic.Text,\n            description: topic.Text,\n            url: topic.FirstURL,\n            source: 'web' as const,\n            score: 0.8,\n          });\n        }\n      });\n    }\n    \n    return results;\n  } catch (error) {\n    console.error('Web search error:', error);\n    return [];\n  }\n}\n\n// Main search function\nexport async function searchAll(query: string, options: SearchOptions = {}): Promise<SearchResult[]> {\n  const results: SearchResult[] = [];\n  \n  try {\n    // Run all searches in parallel\n    const [stackOverflowResults, githubResults, npmResults, mdnResults, webResults] = await Promise.all([\n      searchStackOverflow(query, options),\n      searchGitHub(query, options),\n      searchNPM(query, options),\n      searchMDN(query, options),\n      searchWeb(query, options),\n    ]);\n    \n    // Combine and sort results\n    results.push(...stackOverflowResults);\n    results.push(...githubResults);\n    results.push(...npmResults);\n    results.push(...mdnResults);\n    results.push(...webResults);\n    \n    // Sort by score (if available) or relevance\n    results.sort((a, b) => (b.score || 0) - (a.score || 0));\n    \n    // Limit results\n    return results.slice(0, options.limit || 20);\n  } catch (error) {\n    console.error('Search error:', error);\n    return [];\n  }\n}\n\n// Search specific source\nexport async function searchSource(source: string, query: string, options: SearchOptions = {}): Promise<SearchResult[]> {\n  switch (source) {\n    case 'stackoverflow':\n      return await searchStackOverflow(query, options);\n    case 'github':\n      return await searchGitHub(query, options);\n    case 'npm':\n      return await searchNPM(query, options);\n    case 'mdn':\n      return await searchMDN(query, options);\n    case 'web':\n      return await searchWeb(query, options);\n    case 'all':\n      return await searchAll(query, options);\n    default:\n      return [];\n  }\n}\n\n// Get search suggestions\nexport async function getSearchSuggestions(query: string): Promise<string[]> {\n  try {\n    // Use DuckDuckGo for suggestions\n    const response = await axios.get(`https://duckduckgo.com/ac/?q=${encodeURIComponent(query)}`);\n    \n    return response.data.map((item: any) => item.phrase).slice(0, 5);\n  } catch (error) {\n    console.error('Suggestions error:', error);\n    return [];\n  }\n}\n\n// Search code snippets\nexport async function searchCodeSnippets(query: string, language?: string): Promise<SearchResult[]> {\n  try {\n    const searchQuery = language ? `${query} language:${language}` : query;\n    \n    // Search GitHub for code\n    const githubResults = await searchGitHub(searchQuery, { limit: 5 });\n    \n    // Search Stack Overflow for code examples\n    const soResults = await searchStackOverflow(searchQuery, { limit: 5 });\n    \n    return [...githubResults, ...soResults];\n  } catch (error) {\n    console.error('Code search error:', error);\n    return [];\n  }\n}\n\n// Search documentation\nexport async function searchDocumentation(query: string, framework?: string): Promise<SearchResult[]> {\n  try {\n    const searchQuery = framework ? `${framework} ${query}` : query;\n    \n    // Search MDN for web documentation\n    const mdnResults = await searchMDN(searchQuery, { limit: 5 });\n    \n    // Search GitHub for documentation repos\n    const githubResults = await searchGitHub(`${searchQuery} documentation`, { limit: 3 });\n    \n    return [...mdnResults, ...githubResults];\n  } catch (error) {\n    console.error('Documentation search error:', error);\n    return [];\n  }\n}\n\n",
    "hash": "15e704d2cdfd7aebbdcb0e32e262a07f",
    "lastModified": "2025-10-27T08:27:34.506Z",
    "synced": false
  },
  {
    "id": "ba095c684401bf66cd11e3a8a59f1f1c",
    "type": "workspace",
    "path": "/workspace/backend/src/services/securityService.ts",
    "content": "import { exec } from 'child_process';\nimport { promisify } from 'util';\nimport axios from 'axios';\n\nconst execAsync = promisify(exec);\n\nconst WORKSPACE_PATH = process.env.WORKSPACE_PATH || process.cwd();\n\nexport interface Vulnerability {\n  id: string;\n  package: string;\n  severity: 'low' | 'moderate' | 'high' | 'critical';\n  title: string;\n  description: string;\n  fixAvailable: boolean;\n  fixVersion?: string;\n  cve?: string;\n}\n\nexport interface SecurityScanResult {\n  vulnerabilities: Vulnerability[];\n  summary: {\n    total: number;\n    critical: number;\n    high: number;\n    moderate: number;\n    low: number;\n  };\n}\n\nexport async function scanDependencies(manager: string = 'npm'): Promise<SecurityScanResult> {\n  try {\n    switch (manager) {\n      case 'npm':\n        return await scanNpmDependencies();\n      case 'pip':\n        return await scanPipDependencies();\n      case 'cargo':\n        return await scanCargoDependencies();\n      default:\n        return { vulnerabilities: [], summary: { total: 0, critical: 0, high: 0, moderate: 0, low: 0 } };\n    }\n  } catch (error) {\n    console.error('Security scan error:', error);\n    return { vulnerabilities: [], summary: { total: 0, critical: 0, high: 0, moderate: 0, low: 0 } };\n  }\n}\n\nasync function scanNpmDependencies(): Promise<SecurityScanResult> {\n  try {\n    const { stdout } = await execAsync('npm audit --json', { cwd: WORKSPACE_PATH });\n    const auditResult = JSON.parse(stdout);\n    \n    const vulnerabilities: Vulnerability[] = [];\n    \n    if (auditResult.vulnerabilities) {\n      for (const [packageName, vulnData] of Object.entries(auditResult.vulnerabilities as Record<string, any>)) {\n        for (const vuln of vulnData.via) {\n          if (typeof vuln === 'object' && vuln.title) {\n            vulnerabilities.push({\n              id: vuln.id || `${packageName}-${vuln.title}`,\n              package: packageName,\n              severity: mapSeverity(vuln.severity),\n              title: vuln.title,\n              description: vuln.description || '',\n              fixAvailable: vulnData.fixAvailable || false,\n              fixVersion: vulnData.fixAvailable?.version,\n              cve: vuln.cve,\n            });\n          }\n        }\n      }\n    }\n    \n    return {\n      vulnerabilities,\n      summary: {\n        total: vulnerabilities.length,\n        critical: vulnerabilities.filter(v => v.severity === 'critical').length,\n        high: vulnerabilities.filter(v => v.severity === 'high').length,\n        moderate: vulnerabilities.filter(v => v.severity === 'moderate').length,\n        low: vulnerabilities.filter(v => v.severity === 'low').length,\n      },\n    };\n  } catch (error) {\n    console.error('npm audit error:', error);\n    return { vulnerabilities: [], summary: { total: 0, critical: 0, high: 0, moderate: 0, low: 0 } };\n  }\n}\n\nasync function scanPipDependencies(): Promise<SecurityScanResult> {\n  try {\n    // Try pip-audit if available\n    try {\n      const { stdout } = await execAsync('pip-audit --format=json', { cwd: WORKSPACE_PATH });\n      const auditResult = JSON.parse(stdout);\n      \n      const vulnerabilities: Vulnerability[] = auditResult.vulnerabilities.map((vuln: any) => ({\n        id: vuln.id,\n        package: vuln.package,\n        severity: mapSeverity(vuln.severity),\n        title: vuln.summary,\n        description: vuln.description || '',\n        fixAvailable: vuln.fix_versions && vuln.fix_versions.length > 0,\n        fixVersion: vuln.fix_versions?.[0],\n        cve: vuln.id,\n      }));\n      \n      return {\n        vulnerabilities,\n        summary: {\n          total: vulnerabilities.length,\n          critical: vulnerabilities.filter(v => v.severity === 'critical').length,\n          high: vulnerabilities.filter(v => v.severity === 'high').length,\n          moderate: vulnerabilities.filter(v => v.severity === 'moderate').length,\n          low: vulnerabilities.filter(v => v.severity === 'low').length,\n        },\n      };\n    } catch {\n      // Fallback to safety check\n      return await scanWithSafety();\n    }\n  } catch (error) {\n    console.error('pip security scan error:', error);\n    return { vulnerabilities: [], summary: { total: 0, critical: 0, high: 0, moderate: 0, low: 0 } };\n  }\n}\n\nasync function scanWithSafety(): Promise<SecurityScanResult> {\n  try {\n    const { stdout } = await execAsync('safety check --json', { cwd: WORKSPACE_PATH });\n    const safetyResult = JSON.parse(stdout);\n    \n    const vulnerabilities: Vulnerability[] = safetyResult.map((vuln: any) => ({\n      id: vuln.id,\n      package: vuln.package,\n      severity: mapSeverity(vuln.severity),\n      title: vuln.advisory,\n      description: vuln.description || '',\n      fixAvailable: vuln.specs && vuln.specs.length > 0,\n      fixVersion: vuln.specs?.[0],\n    }));\n    \n    return {\n      vulnerabilities,\n      summary: {\n        total: vulnerabilities.length,\n        critical: vulnerabilities.filter(v => v.severity === 'critical').length,\n        high: vulnerabilities.filter(v => v.severity === 'high').length,\n        moderate: vulnerabilities.filter(v => v.severity === 'moderate').length,\n        low: vulnerabilities.filter(v => v.severity === 'low').length,\n      },\n    };\n  } catch {\n    return { vulnerabilities: [], summary: { total: 0, critical: 0, high: 0, moderate: 0, low: 0 } };\n  }\n}\n\nasync function scanCargoDependencies(): Promise<SecurityScanResult> {\n  try {\n    const { stdout } = await execAsync('cargo audit --json', { cwd: WORKSPACE_PATH });\n    const auditResult = JSON.parse(stdout);\n    \n    const vulnerabilities: Vulnerability[] = auditResult.vulnerabilities.map((vuln: any) => ({\n      id: vuln.id,\n      package: vuln.package.name,\n      severity: mapSeverity(vuln.severity),\n      title: vuln.title,\n      description: vuln.description || '',\n      fixAvailable: vuln.versions && vuln.versions.length > 0,\n      fixVersion: vuln.versions?.[0],\n      cve: vuln.id,\n    }));\n    \n    return {\n      vulnerabilities,\n      summary: {\n        total: vulnerabilities.length,\n        critical: vulnerabilities.filter(v => v.severity === 'critical').length,\n        high: vulnerabilities.filter(v => v.severity === 'high').length,\n        moderate: vulnerabilities.filter(v => v.severity === 'moderate').length,\n        low: vulnerabilities.filter(v => v.severity === 'low').length,\n      },\n    };\n  } catch {\n    return { vulnerabilities: [], summary: { total: 0, critical: 0, high: 0, moderate: 0, low: 0 } };\n  }\n}\n\nexport async function scanCodeSecurity(): Promise<Vulnerability[]> {\n  const vulnerabilities: Vulnerability[] = [];\n  \n  try {\n    // Scan for common security issues\n    const patterns = [\n      {\n        pattern: /password\\s*=\\s*[\"'][^\"']+[\"']/gi,\n        severity: 'high' as const,\n        title: 'Hardcoded Password',\n        description: 'Potential hardcoded password found in code',\n      },\n      {\n        pattern: /api[_-]?key\\s*=\\s*[\"'][^\"']+[\"']/gi,\n        severity: 'high' as const,\n        title: 'Hardcoded API Key',\n        description: 'Potential hardcoded API key found in code',\n      },\n      {\n        pattern: /secret\\s*=\\s*[\"'][^\"']+[\"']/gi,\n        severity: 'high' as const,\n        title: 'Hardcoded Secret',\n        description: 'Potential hardcoded secret found in code',\n      },\n      {\n        pattern: /SELECT\\s+.*\\s+FROM\\s+.*\\s+WHERE\\s+.*\\$\\{/gi,\n        severity: 'critical' as const,\n        title: 'SQL Injection Risk',\n        description: 'Potential SQL injection vulnerability',\n      },\n      {\n        pattern: /innerHTML\\s*=\\s*[^;]+/gi,\n        severity: 'moderate' as const,\n        title: 'XSS Risk',\n        description: 'Potential XSS vulnerability with innerHTML',\n      },\n    ];\n    \n    // This would need to be implemented with file scanning\n    // For now, return empty array\n    return vulnerabilities;\n  } catch (error) {\n    console.error('Code security scan error:', error);\n    return [];\n  }\n}\n\nexport async function fixVulnerability(vulnerabilityId: string, manager: string = 'npm'): Promise<void> {\n  try {\n    switch (manager) {\n      case 'npm':\n        await execAsync('npm audit fix', { cwd: WORKSPACE_PATH });\n        break;\n      case 'pip':\n        await execAsync('pip install --upgrade pip', { cwd: WORKSPACE_PATH });\n        break;\n      case 'cargo':\n        await execAsync('cargo update', { cwd: WORKSPACE_PATH });\n        break;\n      default:\n        throw new Error(`Unsupported package manager: ${manager}`);\n    }\n  } catch (error) {\n    console.error('Error fixing vulnerability:', error);\n    throw error;\n  }\n}\n\nfunction mapSeverity(severity: string): 'low' | 'moderate' | 'high' | 'critical' {\n  const s = severity.toLowerCase();\n  if (s.includes('critical')) return 'critical';\n  if (s.includes('high')) return 'high';\n  if (s.includes('moderate') || s.includes('medium')) return 'moderate';\n  return 'low';\n}\n\nexport async function getCVEInfo(cveId: string): Promise<any> {\n  try {\n    const response = await axios.get(`https://cve.circl.lu/api/cve/${cveId}`);\n    return response.data;\n  } catch (error) {\n    console.error('Error fetching CVE info:', error);\n    return null;\n  }\n}\n\n",
    "hash": "753c7b61654a1eb2597ded66d8335e61",
    "lastModified": "2025-10-27T08:27:34.506Z",
    "synced": false
  },
  {
    "id": "bbda85b79bb526b9c63ce5d21809323c",
    "type": "workspace",
    "path": "/workspace/backend/src/services/terminalService.ts",
    "content": "import { spawn, ChildProcess } from 'child_process';\nimport type { Socket } from 'socket.io';\nimport os from 'os';\n\nconst terminals = new Map<string, ChildProcess>();\n\nexport function setupTerminalHandlers(socket: Socket) {\n  socket.on('terminal:create', () => {\n    try {\n      const shell = os.platform() === 'win32' ? 'powershell.exe' : 'bash';\n      \n      const term = spawn(shell, [], {\n        cwd: process.env.WORKSPACE_PATH || process.cwd(),\n        env: process.env,\n        stdio: ['pipe', 'pipe', 'pipe']\n      });\n\n      terminals.set(socket.id, term);\n\n      term.stdout?.on('data', (data) => {\n        socket.emit('terminal:output', { data: data.toString() });\n      });\n\n      term.stderr?.on('data', (data) => {\n        socket.emit('terminal:output', { data: data.toString() });\n      });\n\n      term.on('exit', () => {\n        terminals.delete(socket.id);\n        socket.emit('terminal:exit');\n      });\n\n      term.on('error', (error) => {\n        console.error('[Terminal] Error:', error);\n        socket.emit('terminal:error', { error: error.message });\n      });\n\n      socket.emit('terminal:ready');\n    } catch (error: any) {\n      console.error('[Terminal] Error creating terminal:', error);\n      socket.emit('terminal:error', { error: error.message });\n    }\n  });\n\n  socket.on('terminal:input', (data: { data: string }) => {\n    try {\n      const term = terminals.get(socket.id);\n      if (term && term.stdin) {\n        term.stdin.write(data.data);\n      } else {\n        socket.emit('terminal:error', { error: 'Terminal not found' });\n      }\n    } catch (error: any) {\n      console.error('[Terminal] Error handling input:', error);\n      socket.emit('terminal:error', { error: error.message });\n    }\n  });\n\n  socket.on('terminal:resize', (data: { cols: number; rows: number }) => {\n    // Note: Basic spawn doesn't support resize, but we'll keep the interface\n    socket.emit('terminal:output', { data: `\\x1b[8;${data.rows};${data.cols}t` });\n  });\n\n  socket.on('disconnect', () => {\n    const term = terminals.get(socket.id);\n    if (term) {\n      term.kill();\n      terminals.delete(socket.id);\n    }\n  });\n}\n\n",
    "hash": "7d4205106316fb87e17f804ea6a07c22",
    "lastModified": "2025-10-27T08:37:07.228Z",
    "synced": false
  },
  {
    "id": "62229dbe28f4a6b356602e72e69a7ffb",
    "type": "workspace",
    "path": "/workspace/backend/src/services/voiceService.ts",
    "content": "import { exec } from 'child_process';\nimport { promisify } from 'util';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport axios from 'axios';\n\nconst execAsync = promisify(exec);\n\nexport interface VoiceCommand {\n  id: string;\n  phrase: string;\n  action: string;\n  parameters?: Record<string, any>;\n  enabled: boolean;\n  confidence: number;\n}\n\nexport interface VoiceSession {\n  id: string;\n  isActive: boolean;\n  wakeWord: string;\n  language: string;\n  commands: VoiceCommand[];\n  startTime: Date;\n  lastActivity: Date;\n}\n\nexport interface VoiceConfig {\n  wakeWord: string;\n  language: string;\n  sensitivity: number;\n  timeout: number;\n  enabled: boolean;\n  commands: VoiceCommand[];\n}\n\nclass VoiceService {\n  private sessions: Map<string, VoiceSession> = new Map();\n  private config: VoiceConfig;\n  private isListening: boolean = false;\n  private currentSession: string | null = null;\n\n  constructor() {\n    this.config = {\n      wakeWord: 'hey tantra',\n      language: 'en-US',\n      sensitivity: 0.7,\n      timeout: 5000,\n      enabled: true,\n      commands: this.getDefaultCommands(),\n    };\n  }\n\n  private getDefaultCommands(): VoiceCommand[] {\n    return [\n      {\n        id: 'open-file',\n        phrase: 'open file',\n        action: 'file.open',\n        enabled: true,\n        confidence: 0.8,\n      },\n      {\n        id: 'save-file',\n        phrase: 'save file',\n        action: 'file.save',\n        enabled: true,\n        confidence: 0.8,\n      },\n      {\n        id: 'new-file',\n        phrase: 'new file',\n        action: 'file.new',\n        enabled: true,\n        confidence: 0.8,\n      },\n      {\n        id: 'run-code',\n        phrase: 'run code',\n        action: 'code.run',\n        enabled: true,\n        confidence: 0.8,\n      },\n      {\n        id: 'debug-code',\n        phrase: 'debug code',\n        action: 'code.debug',\n        enabled: true,\n        confidence: 0.8,\n      },\n      {\n        id: 'git-commit',\n        phrase: 'commit changes',\n        action: 'git.commit',\n        enabled: true,\n        confidence: 0.8,\n      },\n      {\n        id: 'git-push',\n        phrase: 'push changes',\n        action: 'git.push',\n        enabled: true,\n        confidence: 0.8,\n      },\n      {\n        id: 'search-code',\n        phrase: 'search for',\n        action: 'search.code',\n        enabled: true,\n        confidence: 0.8,\n      },\n      {\n        id: 'ai-help',\n        phrase: 'ai help',\n        action: 'ai.chat',\n        enabled: true,\n        confidence: 0.8,\n      },\n      {\n        id: 'deploy-app',\n        phrase: 'deploy app',\n        action: 'deploy.start',\n        enabled: true,\n        confidence: 0.8,\n      },\n    ];\n  }\n\n  async startListening(): Promise<VoiceSession> {\n    if (this.isListening) {\n      throw new Error('Voice service is already listening');\n    }\n\n    const sessionId = `session-${Date.now()}`;\n    const session: VoiceSession = {\n      id: sessionId,\n      isActive: true,\n      wakeWord: this.config.wakeWord,\n      language: this.config.language,\n      commands: this.config.commands,\n      startTime: new Date(),\n      lastActivity: new Date(),\n    };\n\n    this.sessions.set(sessionId, session);\n    this.currentSession = sessionId;\n    this.isListening = true;\n\n    // Start voice recognition in the background\n    this.startVoiceRecognition(sessionId);\n\n    return session;\n  }\n\n  async stopListening(sessionId?: string): Promise<void> {\n    const targetSession = sessionId || this.currentSession;\n    if (!targetSession) return;\n\n    const session = this.sessions.get(targetSession);\n    if (session) {\n      session.isActive = false;\n      this.sessions.delete(targetSession);\n    }\n\n    if (targetSession === this.currentSession) {\n      this.currentSession = null;\n      this.isListening = false;\n    }\n  }\n\n  private async startVoiceRecognition(sessionId: string): Promise<void> {\n    try {\n      // This would integrate with a speech recognition service\n      // For now, we'll simulate voice recognition\n      console.log(`[Voice] Starting recognition for session ${sessionId}`);\n      \n      // In a real implementation, this would:\n      // 1. Connect to a speech recognition service (Web Speech API, Azure, Google, etc.)\n      // 2. Listen for the wake word\n      // 3. Process commands when detected\n      // 4. Execute the corresponding actions\n      \n      // Simulate voice recognition for demo\n      this.simulateVoiceRecognition(sessionId);\n    } catch (error) {\n      console.error('[Voice] Recognition error:', error);\n    }\n  }\n\n  private async simulateVoiceRecognition(sessionId: string): Promise<void> {\n    // This is a simulation - in real implementation, this would be actual voice recognition\n    const session = this.sessions.get(sessionId);\n    if (!session || !session.isActive) return;\n\n    // Simulate detecting wake word after 2 seconds\n    setTimeout(() => {\n      if (session.isActive) {\n        console.log(`[Voice] Wake word \"${session.wakeWord}\" detected`);\n        this.processVoiceCommand(sessionId, 'open file');\n      }\n    }, 2000);\n  }\n\n  async processVoiceCommand(sessionId: string, transcript: string): Promise<void> {\n    const session = this.sessions.get(sessionId);\n    if (!session || !session.isActive) return;\n\n    console.log(`[Voice] Processing command: \"${transcript}\"`);\n\n    // Find matching command\n    const command = this.findMatchingCommand(transcript, session.commands);\n    if (command) {\n      await this.executeVoiceCommand(sessionId, command, transcript);\n    } else {\n      console.log(`[Voice] No matching command found for: \"${transcript}\"`);\n    }\n\n    session.lastActivity = new Date();\n  }\n\n  private findMatchingCommand(transcript: string, commands: VoiceCommand[]): VoiceCommand | null {\n    const normalizedTranscript = transcript.toLowerCase().trim();\n    \n    for (const command of commands) {\n      if (!command.enabled) continue;\n      \n      const normalizedPhrase = command.phrase.toLowerCase();\n      \n      // Simple string matching - in real implementation, use fuzzy matching or NLP\n      if (normalizedTranscript.includes(normalizedPhrase)) {\n        return command;\n      }\n    }\n    \n    return null;\n  }\n\n  private async executeVoiceCommand(sessionId: string, command: VoiceCommand, transcript: string): Promise<void> {\n    console.log(`[Voice] Executing command: ${command.action}`);\n    \n    try {\n      switch (command.action) {\n        case 'file.open':\n          await this.handleFileOpen(transcript);\n          break;\n        case 'file.save':\n          await this.handleFileSave();\n          break;\n        case 'file.new':\n          await this.handleFileNew(transcript);\n          break;\n        case 'code.run':\n          await this.handleCodeRun();\n          break;\n        case 'code.debug':\n          await this.handleCodeDebug();\n          break;\n        case 'git.commit':\n          await this.handleGitCommit(transcript);\n          break;\n        case 'git.push':\n          await this.handleGitPush();\n          break;\n        case 'search.code':\n          await this.handleSearchCode(transcript);\n          break;\n        case 'ai.chat':\n          await this.handleAiChat(transcript);\n          break;\n        case 'deploy.start':\n          await this.handleDeployStart();\n          break;\n        default:\n          console.log(`[Voice] Unknown command: ${command.action}`);\n      }\n    } catch (error) {\n      console.error(`[Voice] Error executing command ${command.action}:`, error);\n    }\n  }\n\n  private async handleFileOpen(transcript: string): Promise<void> {\n    // Extract filename from transcript\n    const filename = this.extractFilename(transcript);\n    console.log(`[Voice] Opening file: ${filename}`);\n    // This would trigger the file open action in the frontend\n  }\n\n  private async handleFileSave(): Promise<void> {\n    console.log('[Voice] Saving current file');\n    // This would trigger the file save action in the frontend\n  }\n\n  private async handleFileNew(transcript: string): Promise<void> {\n    const filename = this.extractFilename(transcript);\n    console.log(`[Voice] Creating new file: ${filename}`);\n    // This would trigger the file creation action in the frontend\n  }\n\n  private async handleCodeRun(): Promise<void> {\n    console.log('[Voice] Running current code');\n    // This would trigger the code execution in the terminal\n  }\n\n  private async handleCodeDebug(): Promise<void> {\n    console.log('[Voice] Starting debug session');\n    // This would trigger the debugger\n  }\n\n  private async handleGitCommit(transcript: string): Promise<void> {\n    const message = this.extractCommitMessage(transcript);\n    console.log(`[Voice] Committing with message: ${message}`);\n    // This would trigger git commit\n  }\n\n  private async handleGitPush(): Promise<void> {\n    console.log('[Voice] Pushing to remote');\n    // This would trigger git push\n  }\n\n  private async handleSearchCode(transcript: string): Promise<void> {\n    const query = this.extractSearchQuery(transcript);\n    console.log(`[Voice] Searching for: ${query}`);\n    // This would trigger code search\n  }\n\n  private async handleAiChat(transcript: string): Promise<void> {\n    const question = this.extractQuestion(transcript);\n    console.log(`[Voice] AI question: ${question}`);\n    // This would trigger AI chat\n  }\n\n  private async handleDeployStart(): Promise<void> {\n    console.log('[Voice] Starting deployment');\n    // This would trigger deployment\n  }\n\n  private extractFilename(transcript: string): string {\n    // Simple extraction - in real implementation, use NLP\n    const words = transcript.split(' ');\n    const fileIndex = words.findIndex(word => word === 'file');\n    if (fileIndex !== -1 && words[fileIndex + 1]) {\n      return words[fileIndex + 1];\n    }\n    return 'untitled.txt';\n  }\n\n  private extractCommitMessage(transcript: string): string {\n    // Extract commit message from transcript\n    const messageIndex = transcript.indexOf('message');\n    if (messageIndex !== -1) {\n      return transcript.substring(messageIndex + 8).trim();\n    }\n    return 'Voice commit';\n  }\n\n  private extractSearchQuery(transcript: string): string {\n    // Extract search query from transcript\n    const forIndex = transcript.indexOf('for');\n    if (forIndex !== -1) {\n      return transcript.substring(forIndex + 4).trim();\n    }\n    return transcript;\n  }\n\n  private extractQuestion(transcript: string): string {\n    // Extract question from transcript\n    const helpIndex = transcript.indexOf('help');\n    if (helpIndex !== -1) {\n      return transcript.substring(helpIndex + 5).trim();\n    }\n    return transcript;\n  }\n\n  async addCommand(command: VoiceCommand): Promise<void> {\n    this.config.commands.push(command);\n  }\n\n  async removeCommand(commandId: string): Promise<void> {\n    this.config.commands = this.config.commands.filter(cmd => cmd.id !== commandId);\n  }\n\n  async updateConfig(config: Partial<VoiceConfig>): Promise<void> {\n    this.config = { ...this.config, ...config };\n  }\n\n  getConfig(): VoiceConfig {\n    return { ...this.config };\n  }\n\n  getSessions(): VoiceSession[] {\n    return Array.from(this.sessions.values());\n  }\n\n  getCurrentSession(): VoiceSession | null {\n    return this.currentSession ? this.sessions.get(this.currentSession) || null : null;\n  }\n\n  isVoiceActive(): boolean {\n    return this.isListening;\n  }\n}\n\nexport const voiceService = new VoiceService();",
    "hash": "443bc9947cc99c0168f2b60b0ecc2f13",
    "lastModified": "2025-10-27T08:27:34.506Z",
    "synced": false
  },
  {
    "id": "30579b5e12e16aa87a658e28d3c40005",
    "type": "workspace",
    "path": "/workspace/backend/src/tools/aiTools.ts",
    "content": "import { exec } from 'child_process';\nimport { promisify } from 'util';\nimport * as fileService from '../services/fileService.js';\nimport path from 'path';\n\nconst execAsync = promisify(exec);\n\nexport interface ToolCall {\n  id: string;\n  name: string;\n  parameters: Record<string, any>;\n  result?: any;\n  status: 'pending' | 'running' | 'completed' | 'failed';\n  error?: string;\n}\n\nexport interface ToolDefinition {\n  name: string;\n  description: string;\n  parameters: {\n    type: 'object';\n    properties: Record<string, any>;\n    required: string[];\n  };\n}\n\nexport const TOOLS: ToolDefinition[] = [\n  {\n    name: 'read_file',\n    description: 'Read the contents of a file',\n    parameters: {\n      type: 'object',\n      properties: {\n        path: {\n          type: 'string',\n          description: 'The path to the file to read',\n        },\n      },\n      required: ['path'],\n    },\n  },\n  {\n    name: 'write_file',\n    description: 'Write content to a file (creates if doesn\\'t exist)',\n    parameters: {\n      type: 'object',\n      properties: {\n        path: {\n          type: 'string',\n          description: 'The path to the file to write',\n        },\n        content: {\n          type: 'string',\n          description: 'The content to write to the file',\n        },\n      },\n      required: ['path', 'content'],\n    },\n  },\n  {\n    name: 'list_files',\n    description: 'List files and directories in a directory',\n    parameters: {\n      type: 'object',\n      properties: {\n        directory: {\n          type: 'string',\n          description: 'The directory path to list',\n        },\n      },\n      required: ['directory'],\n    },\n  },\n  {\n    name: 'search_code',\n    description: 'Search for code patterns in files',\n    parameters: {\n      type: 'object',\n      properties: {\n        pattern: {\n          type: 'string',\n          description: 'The search pattern (regex or text)',\n        },\n        path: {\n          type: 'string',\n          description: 'The directory to search in',\n        },\n      },\n      required: ['pattern'],\n    },\n  },\n  {\n    name: 'run_command',\n    description: 'Execute a terminal command',\n    parameters: {\n      type: 'object',\n      properties: {\n        command: {\n          type: 'string',\n          description: 'The command to execute',\n        },\n        cwd: {\n          type: 'string',\n          description: 'Working directory for the command',\n        },\n      },\n      required: ['command'],\n    },\n  },\n  {\n    name: 'create_file',\n    description: 'Create a new file with content',\n    parameters: {\n      type: 'object',\n      properties: {\n        path: {\n          type: 'string',\n          description: 'The path for the new file',\n        },\n        content: {\n          type: 'string',\n          description: 'The initial content of the file',\n        },\n      },\n      required: ['path'],\n    },\n  },\n  {\n    name: 'delete_file',\n    description: 'Delete a file or directory',\n    parameters: {\n      type: 'object',\n      properties: {\n        path: {\n          type: 'string',\n          description: 'The path to delete',\n        },\n      },\n      required: ['path'],\n    },\n  },\n  {\n    name: 'create_directory',\n    description: 'Create a new directory',\n    parameters: {\n      type: 'object',\n      properties: {\n        path: {\n          type: 'string',\n          description: 'The path for the new directory',\n        },\n      },\n      required: ['path'],\n    },\n  },\n];\n\nexport async function executeTool(toolCall: ToolCall): Promise<ToolCall> {\n  const { name, parameters } = toolCall;\n  \n  try {\n    toolCall.status = 'running';\n    \n    let result: any;\n    \n    switch (name) {\n      case 'read_file':\n        result = await fileService.readFile(parameters.path);\n        break;\n        \n      case 'write_file':\n        await fileService.writeFile(parameters.path, parameters.content);\n        result = { success: true, message: 'File written successfully' };\n        break;\n        \n      case 'create_file':\n        await fileService.createFile(parameters.path, parameters.content || '');\n        result = { success: true, message: 'File created successfully' };\n        break;\n        \n      case 'delete_file':\n        await fileService.deleteFile(parameters.path);\n        result = { success: true, message: 'File deleted successfully' };\n        break;\n        \n      case 'create_directory':\n        await fileService.createFolder(parameters.path);\n        result = { success: true, message: 'Directory created successfully' };\n        break;\n        \n      case 'list_files':\n        const files = await fileService.getFileTree(parameters.directory || '.');\n        result = files;\n        break;\n        \n      case 'search_code':\n        const searchResults = await fileService.searchFiles(parameters.pattern, parameters.path || '.');\n        result = searchResults;\n        break;\n        \n      case 'run_command':\n        const { stdout, stderr } = await execAsync(parameters.command, {\n          cwd: parameters.cwd || process.cwd(),\n          timeout: 30000, // 30 second timeout\n        });\n        result = {\n          stdout,\n          stderr,\n          success: true,\n        };\n        break;\n        \n      default:\n        throw new Error(`Unknown tool: ${name}`);\n    }\n    \n    toolCall.result = result;\n    toolCall.status = 'completed';\n    \n  } catch (error: any) {\n    toolCall.status = 'failed';\n    toolCall.error = error.message;\n    toolCall.result = { error: error.message };\n  }\n  \n  return toolCall;\n}\n\nexport function getToolDefinitions(): ToolDefinition[] {\n  return TOOLS;\n}\n\nexport function validateToolCall(toolCall: ToolCall): boolean {\n  const tool = TOOLS.find(t => t.name === toolCall.name);\n  if (!tool) return false;\n  \n  // Check required parameters\n  for (const required of tool.parameters.required) {\n    if (!(required in toolCall.parameters)) {\n      return false;\n    }\n  }\n  \n  return true;\n}\n\n",
    "hash": "b28fd57d70500337cffddb0342eb8bf9",
    "lastModified": "2025-10-27T08:27:34.506Z",
    "synced": false
  },
  {
    "id": "58a3eee404c58ec0a78e20f097b261ca",
    "type": "workspace",
    "path": "/workspace/backend/tsconfig.json",
    "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"ESNext\",\n    \"lib\": [\"ES2020\"],\n    \"moduleResolution\": \"node\",\n    \"resolveJsonModule\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"strict\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true,\n    \"noUnusedLocals\": false,\n    \"noUnusedParameters\": false,\n    \"noImplicitReturns\": false,\n    \"noFallthroughCasesInSwitch\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n\n",
    "hash": "a0473afd3aed049ac904fea7534cef51",
    "lastModified": "2025-10-27T08:50:32.610Z",
    "synced": false
  }
]